[{"title":"常见Android文件格式","url":"/2019/11/06/常见Android文件格式/","content":"\n## 库文件\n\n　　库文件是一系列代码功能接口与资源数据的有机集合,在开发兼容不同版本系统的apk程序时,需要引入Android SDK中不同版本的android.jar文件.\n\n### jar包\n\n　　jar包其实是一个zip格式的文件,里面存放着编译后JAVA代码的class文件的集合.\n\n　　分析jar包:\n\n  1. 静态分析\n\n     　　使用jd-gui这类jar查看工具\n\n  2. 动态分析\n\n     　　PC平台上可以使用与系统特性相关的工具Dtrace或soot对jar包中的文件进行运行时跟踪\n\n     　　在Android平台中,需要将jar包集成到自己编写的apk中,再对需要分析的jar包中的类与方法进行插桩和运行时分析.\n\n### aar包\n\n　　android studio将aar文件作为全新的库文件格式,aar除了可以包含代码,还可以包含任何在开发中使用的资源数据.\n\n　　aar目录结构与apk文件类似,`class.jar`包含aar库文件中所有代码生成后的class文件,`res`目录存放所有资源,\n\n`aidl`目录存放了AIDL接口文件,`assets`目录中存放了Assets资源.`jni`目录中存放了编译好的不同版本的so库,`libs`目录中存放了aar包引用的第三方jar包,AndroidManifest.xml文件可用于定义aar包的名称,编译器版本等.\n\n​\t\t\n\n## classes.dex\n\n### dex文件验证与优化\n\n　　为了使Android程序在Dalvik虚拟机中快速,顺畅运行,有必要对Dex文件进行验证与优化,Android提供了一个专门验证与优化DEX文件的工具dexopt.\n\n### dex文件修改\n\n　　使用IDA pro定位代码,然后进行修改,修改之后的dex文件其checksum与signature字段是错误的.需要进行修正.修正方法:\n\n1. 使用010 Editor编辑器,配合脚本功能Dexfixer.lsc\n2. dex2jar提供的工具d2j-dex-recompute-checksum\n\n### MultiDex\n\n　　`MultiDex`称为dex分包技术.\n\n　　"},{"title":"Dalvik可执行格式与字节码规范","url":"/2019/11/04/Dalvik可执行格式与字节码规范/","content":"\nAndroid平台使用java语言来开发应用程序,但Android程序并不是运行在标准的java虚拟机上.\n\n## Dalvik虚拟机\n\n### 特点\n\n* 体积小,占用内存小\n\n* 专用dex可执行文件格式,执行速度快\n\n* 常量池采用32位索引值,对类方法名,字段名,常量寻址速度快\n\n* 寄存器架构,拥有一套完整的指令系统\n\n* 所有android程序都运行在Android系统进程中,每个进程都与一个Dalvik虚拟机实例对应.\n\n  \n\n### Dalvik虚拟机与java虚拟机的区别\n\n* 运行字节码不同,一个java字节码,一个dalvik字节码,dalvik字节码由java字节码转换过来\n* Dalvik可执行文件的体积更小\n* 虚拟机架构不同,java虚拟机是基于栈架构的.dalvik是基于寄存器架构的,访问速度快很多\n\n\n\n### 虚拟机执行流程\n\nAndroid系统由Linux内核,函数库,Android运行时,应用程序框架和应用程序组成.Dalvik属于Android运行时\n\n![Android架构](Dalvik可执行格式与字节码规范/android系统架构.jpg)\n\n\n\n​\t\tAndroid系统启动并加载内核后,会立即执行init进程.init进程先完成设备的初始化工作,再读取init.rc文件并启动系统中重要的外部程序Zygote.\n\n​\t\tZygote是Android系统中所有进程的孵化器进程.Zygote启动后,会先初始化Dalvik虚拟机,再启动system_server进程并进入Zygote模式.在执行一个Android应用程序时,system_server进程通过Binder IPC方式将命令发送给Zygote.Zygote收到命令后,通过fork自身创建一个Dalvik虚拟机的实例来执行应用程序的入口函数.从而完成程序的启动过程.\n\n​\t\t进程fork后,执行工作交给Dalvik虚拟机来完成.\n\n\n\n### 虚拟机的执行方式\n\n即时编译(JIT)又称动态编译,是通过在运行时将字节码翻译为机器码使得程序的执行速度加快的技术.\n\n主流JIT包括两种字节码编译方式\n\n* method方式:以方法为单位进行编译\n* trace方式:以trace为单位进行编译\n\nDalvik虚拟机默认采用trace的方式编译代码\n\n## Dalvik语法基础\n\n### Dalvik寄存器\n\nv命名法:表示函数所使用的局部变量与参数\n\np命名法:函数中引入的参数命名从p0开始\n\n\n\n## 参考文章\n\n[Dalvik虚拟机学习之路]( https://www.jianshu.com/p/92c2f732d2d6 )\n\n[Dalvik虚拟机原理]( https://www.jianshu.com/p/14147171a599 )\n\n"},{"title":"dex格式解析","url":"/2019/10/30/dex格式解析/","content":"\n## 前言\n\n​\t\t我们都知道 .java 源文件经过编译器编译会生成 JVM 可识别的 .class 文件。在 Android 中，不管是 Dalvik 还是 Art，和 JVM 的区别还是很大的。Android 系统并不直接使用 Class 文件，而是将所有的 Class 文件聚合打包成 DEX 文件，DEX 文件相比单个单个的 Class 文件更加紧凑，可以直接在 Android Runtime 下执行。\n\n​\t\t 当java程序编译成class后，还需要使用dx工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，实验表明，dex文件是传统jar文件大小的50%左右 . dex文件作为Android APK的组成部分，其主要是Android的Java代码经过编译生成class文件，再经过dx命令生成的。这里面包括了APK的源码，反编译时最主要就是对这个文件进行反编译。 \n\n![android文件](dex格式解析/安卓文件.png)\n\n## dex文件结构\n\n![dex文件格式](https://upload-images.jianshu.io/upload_images/2466095-82f7d70102fe33d2)\n\n## dex文件分析\n\n dex 文件的分析，主要分为三大块： ① Dex 文件头 ② 各种数据的数组，包括字符串、类型、方法原型、字段、方法 ③ 类数据 ④ 其他 \n\n使用010 Editor打开dex文件\n\n![010 Editor dex文件分析](dex格式解析/dex分析.png)\n\n## 参考文章\n\n[Android逆向笔记 —— DEX 文件格式解析](https://www.jianshu.com/p/a4632f566039)\n\n[Android dex文件解析]( https://www.jianshu.com/p/b79c729f326b )\n\n[Android逆向之Dex文件]( https://www.cnblogs.com/ltyandy/p/11603083.html )\n\n"},{"title":"aar和jar文件简介","url":"/2019/10/29/aar和jar文件简介/","content":"\n## 前言\n\n​\t\t在使用 Eclipse 开发 Android 的那个时代（其实也就几年前而已），如果想代码打包，只有 `JAR` 包一个方法，但是 `JAR` 只能把 Java 文件代码打包进去，如果要使用一个有布局和资源的库的话，除了将 `JAR` 放入 libs 外,还需要引入相关的资源和配置文件，十分不优雅。\n\n​\t\tAndroid Studio 出来之后，出现了一个新的方法，打包 `AAR` 文件 ，这个不仅可以把 Java 文件给打进去，还包含 AndroidManifest.xml 和资源文件等，使用的话，直接引入一个 `AAR` 文件就足够了，非常方便。\n\n## jar和aar的区别\n\n*.jar：只包含了class文件与清单文件，不包含资源文件，如图片等所有res中的文件。\n\n*.aar：包含所有资源，class以及res资源文件全部包含\n\n如果你只是一个简单的类库那么使用生成的.jar文件即可；如果你的是一个UI库，包含一些自己写的控件布局文件以及字体等资源文件那么就只能使用.aar文件。\n\n1. *.jar，JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。找一个jar文件，然后修改后缀名为‘zip’或者‘rar’格式，然后解压该文件，打开解压后的文件夹，截图如下所示：\n2. *.jar，JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。\n\n\t## ARR文件结构\n\naar包是Android Library Project的二进制发布包。\n\n文件的扩展名是aar，而且maven包类型也应该是aar， 不过这文件本身就是一个简单的zip文件，里面有如下的内容：\n\n- /AndroidManifest.xml (必须)\n- /classes.jar (必须)\n- /res/ (必须)\n- /R.txt (必须)\n- /assets/ (可选)\n- /libs/*.jar (可选)\n- /jni/<abi>/*.so (可选)\n- /proguard.txt (可选)\n- /lint.jar (可选)\n\n这些条目，都在zip文件的根目录下。\n\nR.txt 文件是 aapt --output-text-symbols 的输出。\n\n## 参考文章\n\n[jar包与aar包文件的区别]( https://www.jianshu.com/p/d7ef84586949 )\n\n[Android中aar与jar的区别]( https://www.jianshu.com/p/0a2572a63ed5 )"},{"title":"如何分析一个程序","url":"/2019/10/29/如何分析一个程序/","content":"\n## 编写一个安卓程序\n\n在 Android studio 中编写一个注册码的应用程序\n\n![app](如何分析一个程序/app.png)\n\n```JAVA\nprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        setTitle(R.string.unregister);\n        final EditText edit_username = (EditText)findViewById(R.id.editText1);\n        final EditText edit_sn = (EditText)findViewById(R.id.editText2);\n        final Button btn_register = (Button)findViewById(R.id.button);\n        btn_register.setOnClickListener(new View.OnClickListener(){\n            public void onClick(View v){\n                if (!checkSN(edit_username.getText().toString().trim(),edit_sn.getText().toString().trim())){\n                    Toast.makeText(MainActivity.this,R.string.unsuccessed,Toast.LENGTH_SHORT).show();\n                }\n                else{\n                    Toast.makeText(MainActivity.this,R.string.successed,Toast.LENGTH_SHORT).show();\n                    btn_register.setEnabled(false);\n                    setTitle(R.string.registered);\n                }\n            }\n        });\n    }\n    \n```\n\ncheckSN用于验证用户名和注册码是否匹配.\n\n```java\nprivate boolean checkSN(String username, String sn) {\n        try{\n            if ((username == null) || (username.length() == 0)) {\n                return false;\n            }\n            if ((sn == null) || (sn.length() != 16)) {\n                return false;\n            }\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(username.getBytes());\n            String hexstr = \"\";\n            StringBuffer hexString = new StringBuffer();\n            byte[] bytes = digest.digest();\n            for (int i=0; i<bytes.length; i++){\n                if(Integer.toHexString(0xFF & bytes[i]).length() < 2){\n                    hexstr = \"0\"+Integer.toHexString(0xFF & bytes[i]);\n                }else{\n                    hexstr = Integer.toHexString(0xFF & bytes[i]);\n                }\n                hexString.append(hexstr);\n            }\n            StringBuilder sb = new StringBuilder();\n            for(int i =0; i < hexString.length();i+=2){\n                sb.append(hexString.charAt(i));\n            }\n            String userSN = sb.toString();\n            if(!userSN.equalsIgnoreCase(sn)){\n                return false;\n            }\n        }catch(NoSuchAlgorithmException e){\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n```\n\n## Android studio模拟器\n\nAMD的cpu不支持`Android studio`的默认AVD,可以使用 `genymotion`安卓模拟器\n\n1. 到[官网]( https://www.genymotion.com/ )下载安装个人版`genymotion`\n2. 新建一个虚拟机设备\n3. 在AndroidStudio中下载Genymotion插件: genymotion\n4. 点击 View->toobar ,这样就可以点击genymotion的图标打开\n\n## 破解安卓应用程序\n\n破解Android程序的方法通常是:使用apktool反编译apk文件,生成smali格式的反汇编代码,通过阅读smali文件的代码来理解程序的运行机制,找到突破口,并对代码进行修改;使用Apktool重新编译生成的APK文件并对其进行签名.\n\n* 下载apktool\n  \n*  https://ibotpeaches.github.io/Apktool/install/ \n  \n* 分析apk文件\n\n  ​\t\tapktool反编译apk文件\n\n  ```\n  apktool d ./app.apk -o outdir\n  ```\n\n  \n\n  ​\t\t对大部分Android程序来说,错误提示信息是指引我们找到关键代码的明灯.错误提示代码附近通常就是程序的核心验证代码,错误提示属于Android程序中的字符串资源.\n\n  ​\t\tres/values/strings.xml文件的内容,除了系统默认生成的一系列\"abc_\"开头的字符串,其他都是程序使用的字符串.\n\n  ![Strings.xml](如何分析一个程序/strings.png)\n\n  ​\t\t在开发Android程序时,strings.xml中的字符串资源都在R.java文件的String类中标识,每个字符串都有唯一的int类型的索引值,所有的索引值都在与strings.xml同目录下的public.xml文件中.\n\n  ![public.xml](如何分析一个程序/public.png)\n\n  ​\t\t利用grep 对反编译目录进行查找,找出关键代码所在位置\n\n  ![找出关键代码](如何分析一个程序/grep.png)\n\n* 修改smali代码\n\n  分析其smali代码,然后修改其跳转指令 if-nez 改为 if-eqz (if-eqz与if-nez功能相反)\n\n* 重新编译APK文件并签名\n\n  ```apktool b outdir```\n\n   [apk手动签名](https://hbltjdw.github.io/2019/10/28/apk手动签名/) \n\n  "},{"title":"adb总结","url":"/2019/10/28/adb总结/","content":"\n## adb安装应用\n\n* 开启USB调试\n  1. 模拟器或者USB连接的手机,点击`设置`,连续点击`版本号`,进入`开发者选项`\n  2. 进入`开发者选项`,打开`USB调试`\n\n* adb安装应用\n\n  ````\n  adb devices    \t\t\t\t//查看设备是否在线\n  adb install xxx.apk\t\t\t//安装应用\n  ````\n\n  \n\n## 参考文章\n\n[ADB总结]( https://www.jianshu.com/p/899fef07929f )\n\n"},{"title":"apk手动签名","url":"/2019/10/28/apk手动签名/","content":"\n## V1和V2签名\n\n1. V1签名：\n   来自` JDK （ jarsigner ）`,对 zip 压缩包的每个文件进行验证，签名后还能对压缩包修改（移动/重新压缩文件）\n   对V1签名的 apk/jar 解压,在 META-INF 存放签名文件( MANIFEST.MF, CERT.SF, CERT.RSA )\n   其中 `MANIFEST.MF` 文件保存所有文件的 SHA1 指纹(除了 META-INF 文件),由此可知:**V1签名是对压缩包中单个文件签名验证**\n2. V2签名：\n   来自 Google（apksigner），对 zip 压缩包的整个文件验证，签名后不能修改压缩包(包括 zipalign )\n   对V2签名的 apk 解压,没有发现签名文件,重新压缩后V2签名就失效, 由此可知: **V2签名是对整个 APK 签名验证**\n3. V2签名优点：\n   签名更安全（不能修改压缩包）\n   签名验证时间更短（不需要解压验证），因此安装速度更快\n\n## V2签名过程\n\n1. `zipalign` \n\n   位于 Android SDK/build-tools/SDK 版本 /zipalign.exe\n   zipalign 是对 zip 包对齐的工具，使APK包内未压缩的数据有序排列对齐，从而减少 APP 运行时消耗\n\n   ```\n   zipalign -v 4 in.apk out.apk \t\t//4字节对齐优化命令\n   zipalign -c -v 4 in.apk \t\t\t//检查 APK 是否对齐\n   ```\n\n2. `apksigner`\n\n   这个工具位于SDK目录的`build-tools`目录下。必须说明的是，v2签名方式时在`Android7.0`后才推出的，所以只有版本>25的`SDK\\build-tools\\`中才能找到`apksigner.jar`.\n\n   ```\n   java -jar apksigner.jar sign           \t\t\t//执行签名操作\n   --ks 你的jks路径                                \t//jks签名证书路径\n   --ks-key-alias 你的alias           \t\t\t\t//生成jks时指定的alias\n   --ks-pass pass:你的密码          \t\t\t\t//KeyStore密码\n   --key-pass pass:你的密码   \t\t\t\t\t\t//签署者的密码，即生成jks时指定alias对应的密码\n   --out output.apk                         \t\t//输出路径\n   input.apk                                   \t//被签名的apk\n   \n   ```\n\n   示例\n\n   ```\n   java -jar apksigner.jar sign  --ks key.jks  --ks-key-alias releasekey  --ks-pass pass:pp123456  --key-pass pass:pp123456  --out output.apk  input.apk\n   ```\n\n   \n\n3. 检查是否签名成功\n\n   ```\n   java -jar apksigner.jar verify -v my.apk\n   ```\n\n   \n\n##　参考文章\n\n[Android开发之通过apksigner对apk进行v2签名]( https://www.jianshu.com/p/e1e2fd05bb62 )\n\n[V1 和 V2 签名工具]( https://www.jianshu.com/p/db8751060146 )\n\n"},{"title":"Smali语法学习","url":"/2019/10/25/Smali语法学习/","content":"\n* Smali 简介\n\n  ​\t\t`Dalvik虚拟机`是google专门为`Android`平台设计的一款虚拟机,区别于标准 Java 虚拟机 JVM 的 class 文件格式，`Dalvik VM` 拥有专属的 DEX 可执行文件格式和指令集代码。`smali` 和 `baksmali` 是针对 DEX 执行文件格式的汇编器和反汇编器，反汇编后 DEX 文件会产生`.smali` 后缀的代码文件.`smali`代码拥有特定的格式与语法，`smali`语言是对 `Dalvik` 虚拟机字节码的一种解释。\n\n  ​\t\t虽然主流的 DEX 可执行文件反汇编工具不少，如 `Dedexer`、`IDA Pro` 和 `dex2jar+jd-gui`，但 `Smali `提供反汇编功能的同时，也提供了打包反汇编代码重新生成DEX的功能，因此 `Smali`被广泛地用于 APP 广告注入、汉化和破解，ROM 定制等方面。\n\n  ​\t\t简单来说就是用java写的代码编译成class打包成`dex`文件后使用`baksmali`程序逆向回来的一种语法。\n\n* Smali 学习\n\n  ​\t\t在`Android studio`中查找插件`java2smali`然后就可以把任何JAVA代码转换成`smali`进行学习.\n\n  ​\t\t然后可以对照着java代码来逐行分析这个`smali`文件。注意.line关键字就是用来描述当前代码在java源文件中的行数。然后你可以通过对照两组代码的方法进行反推。这样就可以很轻松的学会看`smali`文件。\n\n* 参考文章\n\n  [Smali语法]( https://blog.csdn.net/Kelaker/article/details/84403369 )\n\n  [Smali 语法解析——Hello World]( https://www.jianshu.com/p/1a2e2da93b72 )\n\n  [github Smali]( https://github.com/JesusFreke/smali )\n\n  [Dalvik 字节码]( https://source.android.google.cn/devices/tech/dalvik/dalvik-bytecode )\n\n"},{"title":"常见逆向分析工具","url":"/2019/10/24/常见逆向分析工具/","content":"\n* `ApkTool` \n\n​\t\tAndroid逆向分析工具,提供了APK的反编译与回编译的功能,让APK重打包成为可能,以命令行操作的Apktool使用起来更加简单便捷.\n\n\n\n* `smali/baksmali`\n\n​\t\tDEX文件的反编译与回编译工具.提供了smali语法格式,使DEX文件的修改可以基于smali的汇编指令完成.Apktool底层就是使用它提供的dexlib库来生成smali反汇编文件.\n\n\n\n* `dex2jar`\n\n​\t\t将dex文件转换为jar包的工具,转换后的jar包可以利用`jd-gui`等工具查看java代码\n\n\n\n* `010Editor`\n\n​\t\t跨平台的二进制编辑器.可以使用文件格式模板对二进制文件进行查看和编辑."},{"title":"Android程序分析环境搭建","url":"/2019/10/23/Android程序分析环境搭建/","content":"\n## jdk 安装配置\n\n------\n\n* **jdk下载**\n\n```\nhttps://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html\n```\n\n* **jdk环境配置**\n\n|           | 值                                               |\n| --------- | ------------------------------------------------ |\n| CLASSPATH | %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar |\n| JAVA_HOME | C:\\Program Files\\Java\\jdkxxxx                    |\n| PATH      | %JAVA_HOME%\\bin;%JAVA_HOME%\\lib\\tools.jar        |\n\n------\n\n\n\n## Android studio下载\n\n------\n\n\n\n* **Android studio下载**\n\n```\nAndroid studio 下载地址:http://www.android-studio.org/index.php\n下载安装\n```\n\n------\n\n## sdk\n\n------\n\n 目前官网上已经没有单独的SDK下载安装包了。目前官网推荐的是下载包含有Android SDK的Android Studio。 \n\nndk-bundle,cmake,lldb为ndk的工具,新版本的android工程使用cmake构建,并使用lldb进行调试.\n\n![sdk配置](Android程序分析环境搭建/sdk.png)\n\n* **环境变量**\n\n  包含`adb`,`fastboot`的`platform-tools`目录,包含`aapt`,`apksigner`,`dexdump`,`zipalign`的`build-tools/29.0.1`目录,包含`android`,`monitor`的`tools`目录,包含`emulator`的`emulator`目录,加入到Path环境变量中\n\n  在命令行输入`emulator -version`和`adb version`观察输出是否正确\n\n  `NDK`根目录加入到NDK_HOME和Path环境变量中.\n\n  在命令行输入`ndk-bulid -v`观察输出是否正确\n\n------\n\n\n\n## NDK\n\n------\n\n`Native Development kit`\n原生开发工具包（NDK）是一组在 Android 应用中利用 C 和 C++ 代码的工具。因为 Java 无法直接调用 C 和 C++ 的代码，想要在 `Android` 应用中使用原生代码，NDK 便应运而生。NDK是一个包含API、交叉编译器、链接程序、调试器、构建工具、文档和示例应用程序的综合工具集。\nNDK 的核心目的之一是让 C 和 C++ 源代码构建为可用于应用的共享库。\n\n* **`NDK`工具介绍**\n\n  `ndk-build`：编译`Android`动态链接库.so\n  `ndk-gdb`:` GUN`调试器相关\n  `ndk-stack`：原生层堆栈信息 \n\n* **`JNI`**\n\n  `JNI`：`Java Native Interface`，是Java语言提供的一种通用接口，用于Java代码与本地化代码的交互。本地化代码是so文件，它是直接编译成的与机器相关的二进制代码。\n  `jni`通过调用动态链接库（`windows`下是`dll`，`linux`下是`so`）来实现对`C\\C++`方法的调用。\n\n------\n\n\n\n## 参考文章\n\n------\n\n[NDK 简介（Java使用原生代码）]( https://www.jianshu.com/p/a21ed1e90da0 )\n\n"},{"title":"aidl简介","url":"/2019/10/23/aidl简介/","content":"\n## AIDL简介\n\n------\n\n​\t\t`AIDL`是一个缩写，全称是`Android Interface Definition Language`，也就是Android接口定义语言。是的，首先我们知道的第一点就是：`AIDL`是一种语言。\n\n​\t\t 设计`AIDL`这门语言的目的就是为了实现进程间通信。 \n\n​\t\t 其实`AIDL`这门语言非常的简单，基本上它的语法和`Java`是一样的，只是在一些细微处有些许差别.\n\n------\n\n\n\n##  参考文章\n\n------\n\n[Android AIDL使用详解]( https://www.jianshu.com/p/29999c1a93cd )"},{"title":"apk打包流程","url":"/2019/10/23/apk打包流程/","content":"\n## apk打包流程\n\n1.  打包资源文件，生成R.java文件 \n2.  处理AIDL文件，生成对应的.java文件\n3.  编译Java文件，生成对应的.class文件 \n4.  把.class文件转化成Davik VM支持的.dex文件 \n5.  打包生成未签名的.apk文件 \n6.  对未签名.apk文件进行签名 \n7.  对签名后的.apk文件进行对齐处理 \n\n\n\n![apk打包流程](apk打包流程/apk.png)\n\n## apk打包工具介绍\n\n| 工具名称   | 功能介绍                                 |\n| ---------- | ---------------------------------------- |\n| aapt       | Android资源打包工具                      |\n| aidl       | Android接口描述语言转化为.java文件的工具 |\n| javac      | Java Compiler,java代码转class文件        |\n| dex        | 转化.class文件为Davik VM能识别的.dex文件 |\n| apkbuilder | 生成apk包                                |\n| jarsigner  | .jar文件的签名工具                       |\n| zipalign   | 字节码对齐工具                           |\n\n\n\n## 参考文章\n\n[apk打包流程]( https://www.jianshu.com/p/a134d00e81ab )"},{"title":"apk文件结构","url":"/2019/10/22/apk文件结构/","content":"\n* **assets**\n\n  ​\t存放需要打包到APK中的静态文件\n  \n  \n  \n* **lib**\n\n    动态链接库,存放应用程序依赖的native库文件，一般是用C/C++编写，这里的lib库可能包含4中不同类型，根据CPU型号的不同，大体可以分为ARM，ARM-v7a，MIPS，X86，分别对应着ARM架构，ARM-V7架构，MIPS架构和X86架构\n    \n\n\n* **META-INF**\n\n  ​\t存放应用程序签名和证书的目录,签名信息可以验证APK文件的完整性.AndroidSDK在打包APK时会计算APK包中所有文件的完整性，并且把这些完整性保存到META-INF文件夹下，应用程序在安装的时候首先会根据META-INF文件夹校验APK的完整性，这样就可以保证APK中的每一个文件都不能被篡改。\n  \n  \n  \n* **res**\n\n  ​\t存放应用程序的资源,存在这个文件夹下的所有文件都会映射到Android工程的.R文件中\n  \n  \n  \n* **AndroidManifest.xml**\n\n  ​\tAndroid应用程序的配置文件,开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册.\n  \n  \n  \n* **classes.dex**\n\n  ​\t传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。\n  \n  \n  \n* **resources.arsc**\n\n    用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。\n\n------\n\n![APK典型结构](apk文件结构/apk_struct.png)\n\n"},{"title":"Markdown语法","url":"/2019/10/22/Markdown语法/","content":"## `Markdown`常见语法\n\n`Markdown`是兼容`html`的语法的一种轻量级标记语言,它允许人们使用易读易写的纯文本格式编写文档。   \n`Markdown`可以在有道云笔记、Mahua在线编辑、简书等进行编辑\n\n* **标题**\n\n```\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n    #### 四级标题\n    ##### 五级标题\n    ###### 六级标题\n\n```\n\n* **字体**\n\n```\n    **这是加粗的文字**\n    *这是倾斜的文字*`\n    ***这是斜体加粗的文字***\n    ~~这是加删除线的文字~~\n\n```\n\n* **换行**  \n  在上一行后面加两个以上空格，然后另起一行\n\n```\n我是第一行   \n我是第二行\n我是第二行\n\n```\n\n* **列表**  \n  无序列表用 - + * 任何一种都可以  \n\n```\n- 列表内容\n+ 列表内容\n* 列表内容\n\n```\n\n  有序列表 \n\n```\n1.列表内容\n2.列表内容\n3.列表内容\n\n```\n\n* **插入图片**\n\n  * 插入本地图片\n\n    ```\n    ![avatar](/home/picture/1.png)\n    \n    ```\n\n  * 插入网络图片\n\n    ```\n    ![avatar](http://baidu.com/pic/doge.png)\n    \n    ```\n\n  * 把图片存入markdown文件\n\n    用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置.\n\n    ```\n    ![avatar](data:image/png;base64,iVBORw0......)\n    \n    ```\n  \n* **插入超链接**\n\n  ```\n  [超链接文字](url)\n  ```\n\n* **插入表格**\n\n  ```\n  | 一个普通标题 | 一个普通标题 | 一个普通标题 |\n  | ------ | ------ | ------ |\n  | 短文本 | 中等文本 | 稍微长一点的文本 |\n  | 稍微长一点的文本 | 短文本 | 中等文本 |\n  ```\n\n  \n\n"},{"title":"github-hexo搭建个人博客","url":"/2019/10/22/github-hexo搭建个人博客/","content":"------\n\n\n\n## `github`非对称加密认证\n\n------\n\n首先配置用户\n\n```\ngit config --global user.name \"xxx\"\ngit config --global user.email \"xxx@xx.com\"\n```\n\n生成私钥公钥\n\n```\nssh-keygen -t rsa -C \"your email@xxx.com\" \n```\n\n公钥为`id_rsa.pub`,打开,复制\n\n打开浏览器，登录`GitHub`，点击头像，选择`setting`，左侧有个`SSH and GPG keys` ，选择`new SSH key `,title随便写，将复制的内容黏贴上去. \n\n测试一下，`git bash`输入\n\n```\nssh -T git@github.com \n```\n\n------\n\n\n\n## `github page`设置\n\n------\n\n`github page`是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 `Github` 上，你可以选择使用`Github Pages`默认提供的域名 `github.io` 或者自定义域名来发布站点，更便利地是你直接从你的`GitHub`存储库托管。只需编辑和推送你的`blog`，并且你的更改是实时的。\n\n登录`GitHub`并创建一个名为`username.github.io`的新存储库\n\n![github_page](github-hexo搭建个人博客/github_page.png)\n\n------\n\n\n\n## `hexo`安装\n\n------\n\n\n\n1. 安装hexo\n\n```\nnpm install hexo-cli -g\n```\n\n2. 初始化\n\n   安装完成后，建一个文件夹（如`myblog`），执行以下指令(在`myblog`路径下)，`Hexo` 即会自动在目标文件夹建立网站所需要的所有文件\n\n```\nhexo init\nnpm install\n```\n\n------\n\n\n\n## `hexo`发布、删除文章即相关配置\n\n------\n\n\n\n* **`hexo`目录分析**\n\n  ```\n  deploy：执行hexo deploy命令部署到GitHub上的内容目录\n  public：执行hexo generate命令，输出的静态网页内容目录\n  scaffolds：layout模板文件目录，其中的md文件可以添加编辑\n  scripts：扩展脚本目录，这里可以自定义一些javascript脚本\n  source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。\n  drafts：草稿文章\n  posts：发布文章\n  themes：主题文件目录\n  _config.yml：全局配置文件，大多数的设置都在这里\n  package.json：应用程序数据，指明hexo的版本等信息，hexo框架的参数和所依赖插件\n  ```\n\n* **发布文章**\n\n  ```\n  $ hexo new [layout] “title”\n  ```\n\n  layout有三种 `post`、`page` 和 `draft` \n\n  在`_config.yml`中设置默认`layout`为`draft`\n\n  ```\n  default_layout: draft\n  ```\n\n  * 生成草稿\n\n    ```\n    hexo new “title”\n    ```\n\n  * 发布草稿\n\n    ```\n    hexo publish \"title“\n    ```\n\n  * 生成静态文件\n\n    ```\n    hexo clean\n    hexo generate\n    \n    ```\n\n  * 发布到github\n\n    ```\n    hexo deploy\n    ```\n  \n* **删除文章**\n\n  1. 到目录`/source/_posts`下删除相应的文章\n  2. ```$ hexo g```\n  3. ```$ hexo d```\n\n* **插入图片**\n\n  1. 进入博客根目录下,查看`_config.yml`文件,设置`post_asset_folder:true`\n  2. 设置 `post_asset_folder` 参数后，在新建博客文章时，`Hexo` 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到此文件夹内，这样就可以更方便的使用资源。\n  3. 插件的安装``` npm install https://github.com/CodeFalling/hexo-asset-image --save```\n  4. 插入图片时,先把图片复制到文件夹,然后设置图片地址为`文件夹名/图片名称.png`\n------\n\n\n\n## 将`hexo`发布到`github`\n\n------\n\n```\nhexo clean\nhexo generate\nhexo deploy\n```\n\n\n\n------\n\n\n\n## 参考文献\n\n[Github+Hexo一站式部署个人博客](https://www.jianshu.com/p/85192626faf3)\n\n"},{"title":"Hello World","url":"/2019/10/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]