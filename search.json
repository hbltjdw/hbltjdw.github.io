[{"title":"Native函数调用","url":"/2020/01/27/Native函数调用/","content":"\n## 注册JNI函数\n\n* 静态注册\n\n  先由Java得到本地方法的声明，然后再通过JNI实现该声明方法\n\n* 动态注册\n\n  先通过JNI重载`JNI_OnLoad()`实现本地方法，然后直接在Java中调用本地方法。\n\n### 静态注册\n\n​\t\t静态注册就是根据函数名来遍历Java和JNI函数之间的关联，而且要求JNI层函数的名字必须遵循特定的格式。具体的实现很简单，首先在Java代码中声明native函数，然后通过javah来生成native函数的具体形式，接下来在JNI代码中实现这些函数即可。\n\n大致流程:\n\n1. 先创建Java类，声明Native方法，编译成.class文件\n2. 使用`Javah`命令生成C/C++的头文件\n3. 创建.h对应的源文件，然后实现对应的native方法\n\nJNI方法名的规范:**返回值 + Java前缀+全路径类名+方法名+参数1JNIEnv+参数2jobject+其他参数 **\n\n### 动态注册\n\n动态注册，也就是通过`RegisterNatives`方法把C/C++中的方法映射到Java中的native方法，而无需遵循特定的方法命名格式。\n\n举例说明，首先是加载so库\n\n```java\npublic class JniDemo1{\n       static {\n             System.loadLibrary(\"samplelib_jni\");\n        }\n}\n```\n\n在jni中的实现\n\n\n\n```cpp\njint JNI_OnLoad(JavaVM* vm, void* reserved)\n```\n\n并且在这个函数里面去动态的注册native方法，完整的参考代码如下：\n\n```cpp\n#include <jni.h>\n#include \"Log4Android.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic const char *className = \"com/gebilaolitou/jnidemo/JNIDemo2\";\n\nstatic void sayHello(JNIEnv *env, jobject, jlong handle) {\n    LOGI(\"JNI\", \"native: say hello ###\");\n}\n\nstatic JNINativeMethod gJni_Methods_table[] = {\n    {\"sayHello\", \"(J)V\", (void*)sayHello},\n};\n\nstatic int jniRegisterNativeMethods(JNIEnv* env, const char* className,\n    const JNINativeMethod* gMethods, int numMethods)\n{\n    jclass clazz;\n\n    LOGI(\"JNI\",\"Registering %s natives\\n\", className);\n    clazz = (env)->FindClass( className);\n    if (clazz == NULL) {\n        LOGE(\"JNI\",\"Native registration unable to find class '%s'\\n\", className);\n        return -1;\n    }\n\n    int result = 0;\n    if ((env)->RegisterNatives(clazz, gJni_Methods_table, numMethods) < 0) {\n        LOGE(\"JNI\",\"RegisterNatives failed for '%s'\\n\", className);\n        result = -1;\n    }\n\n    (env)->DeleteLocalRef(clazz);\n    return result;\n}\n\njint JNI_OnLoad(JavaVM* vm, void* reserved){\n    LOGI(\"JNI\", \"enter jni_onload\");\n\n    JNIEnv* env = NULL;\n    jint result = -1;\n\n    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {\n        return result;\n    }\n\n    jniRegisterNativeMethods(env, className, gJni_Methods_table, sizeof(gJni_Methods_table) / sizeof(JNINativeMethod));\n\n    return JNI_VERSION_1_4;\n}\n\n\n```\n\n​\t\t然后就调用了`jniRegisterNativeMethods`函数来实现注册，这里面注意一个静态变量`gJni_Methods_table`。JNI允许我们提供一个函数映射表，注册给Java虚拟机，这样JVM就可以用函数映射表来调用相应的函数。这样就可以不必通过函数名来查找需要调用的函数了。Java与JNI通过`JNINativeMethod`的结构来建立联系，它被定义在`jni.h`中，其结构内容如下：。\n\n```c\ntypedef struct {\n    const char* name;\n    const char* signature;\n    void*       fnPtr;\n} JNINativeMethod;\n```\n\n> - 第一个变量`name`，代表的是Java中的**函数名**\n> - 第二个变量`signature`，代表的是Java中的**参数和返回值**\n> - 第三个变量`fnPtr`，代表的是的**指向C函数的函数指针**\n\n\n\n下面我们再来看下`jniRegisterNativeMethods`函数内部的实现\n\n```cpp\nstatic int jniRegisterNativeMethods(JNIEnv* env, const char* className,\n    const JNINativeMethod* gMethods, int numMethods)\n{\n    jclass clazz;\n\n    LOGI(\"JNI\",\"Registering %s natives\\n\", className);\n    clazz = (env)->FindClass( className);\n    if (clazz == NULL) {\n        LOGE(\"JNI\",\"Native registration unable to find class '%s'\\n\", className);\n        return -1;\n    }\n\n    int result = 0;\n    if ((env)->RegisterNatives(clazz, gJni_Methods_table, numMethods) < 0) {\n        LOGE(\"JNI\",\"RegisterNatives failed for '%s'\\n\", className);\n        result = -1;\n    }\n\n    (env)->DeleteLocalRef(clazz);\n    return result;\n}\n```\n\n首先通过`clazz = (env)->FindClass( className);`找到声明native方法的类\n 然后通过调用`RegisterNatives函数`将注册函数的Java类，以及注册函数的数组，以及个数注册在一起，这样就实现了绑定。它的作用就是将Method的nativeFunc指向`dvmCallJNIMethod`，当java层调用native函数的时候会进入这个函数。而真正的native函数指针则存储在`Method->insns`中。\n\n## Native函数调用逻辑\n\n#### 动态注册方法\n\n​\t\tDalvik在执行动态注册的JNI方法时，通过bridge函数`dvmCallJNIMethod`来完成，因为这个Method对象的nativeFunc指向的就是dvmCallJNIMethod。\n\n#### 静态注册方法\n\n​\t\t对于静态注册JNI方法，Dalvik在加载类时会将对应的Method对象的nativeFunc成员设置为dvmResolveNativeMethod函数地址。那么在执行该JNI方法时，就会首先执行dvmResolveNativeMethod.\n\n```c++\nvoid dvmResolveNativeMethod(const u4* args, JValue* pResult,\n   const Method* method, Thread* self)\n{\n   ClassObject* clazz = method->clazz;\n\n   /*\n    * If this is a static method, it could be called before the class\n    * has been initialized.\n    */\n   if (dvmIsStaticMethod(method)) {\n       if (!dvmIsClassInitialized(clazz) && !dvmInitClass(clazz)) {\n           assert(dvmCheckException(dvmThreadSelf()));\n           return;\n       }\n   } else {\n       assert(dvmIsClassInitialized(clazz) ||\n              dvmIsClassInitializing(clazz));\n   }\n\n   /* start with our internal-native methods */\n   DalvikNativeFunc infunc = dvmLookupInternalNativeMethod(method);\n   if (infunc != NULL) {\n       /* resolution always gets the same answer, so no race here */\n       IF_LOGVV() {\n           char* desc = dexProtoCopyMethodDescriptor(&method->prototype);\n           LOGVV(\"+++ resolved native %s.%s %s, invoking\",\n               clazz->descriptor, method->name, desc);\n           free(desc);\n       }\n       if (dvmIsSynchronizedMethod(method)) {\n           ALOGE(\"ERROR: internal-native can't be declared 'synchronized'\");\n           ALOGE(\"Failing on %s.%s\", method->clazz->descriptor, method->name);\n           dvmAbort();     // harsh, but this is VM-internal problem\n       }\n       DalvikBridgeFunc dfunc = (DalvikBridgeFunc) infunc;\n       dvmSetNativeFunc((Method*) method, dfunc, NULL);\n       dfunc(args, pResult, method, self);\n       return;\n   }\n\n   /* now scan any DLLs we have loaded for JNI signatures */\n   void* func = lookupSharedLibMethod(method);\n   if (func != NULL) {\n       /* found it, point it at the JNI bridge and then call it */\n       dvmUseJNIBridge((Method*) method, func);\n       (*method->nativeFunc)(args, pResult, method, self);\n       return;\n   }\n\n   IF_ALOGW() {\n       char* desc = dexProtoCopyMethodDescriptor(&method->prototype);\n       ALOGW(\"No implementation found for native %s.%s:%s\",\n           clazz->descriptor, method->name, desc);\n       free(desc);\n   }\n\n   dvmThrowUnsatisfiedLinkError(\"Native method not found\", method);\n}\n```\n\n\n\n​\t\t`dvmResolveNativeMethod`先遍历查找dalvik虚拟机内部的方法,如果没有找到,继续查找所有已加载的so，找到JNI函数地址后，再调用`dvmUseJNIBridge`函数设置Method的nativeFunc和insns成员，最后再调用`method->nativeFunc`，所以还是先调用`dvmCallJNIMethod`，再由`dvmCallJNIMethod`执行相应的JNI方法。\n\n## 总结\n\n![函数调用](Native函数调用/函数调用流程.png)\n\n​\t\t在Android中，不管是java方法还是java native方法，它在虚拟机中对应的都是一个Method对象，如果这个方法是一个java native方法的话，那么Method对象的nativeFunc会指向一个bridge函数，这个函数为dvmCallJNIMethod，当我们在调用java native函数的时候就会进入这个bridge函数，bridge函数的作用就是调用该java native方法对应的JNI方法。所以，我们可以这么理解，所有java native函数的执行都是通过一个名为dvmCallJNIMethod的bridge函数来实现对应JNI方法的调用的。主动注册与静态注册的区别就是，主动注册需要告诉JNI，Java方法和C函数的映射，而静态注册则按照对应的规则去查找。最后在调用逻辑上，完全一致。\n\n## 参考文献\n\n[Android JNI学习(三)——Java与Native相互调用](https://www.jianshu.com/p/b71aeb4ed13d)\n\n[如何在jni中注册native函数，有几种注册方式?](https://blog.csdn.net/github_37130188/article/details/89857205)\n\n[Dalvik 虚拟机的 dvmCallJNIMethod 方法](https://www.jianshu.com/p/7328c9c5436c)\n\n[Dalvik虚拟机中Java native方法的调用过程](https://blog.csdn.net/hp910315/article/details/79273950)\n\n[JNI实现源码分析【四 函数调用】](https://www.jianshu.com/p/1ef556aec1cd)"},{"title":"JIT与AOT编译模式","url":"/2020/01/26/JIT与AOT编译模式/","content":"\n\n\n JIT，即Just-in-time,动态(即时)编译，边运行边编译；\n\nAOT，Ahead Of Time，指运行前编译，是两种程序的编译方式 \n\n\n\n### JIT\n\n​\t\t JIT，即“Just In Time”，翻译过来就是“即时编译技术”。android在2.2版本引入此技术，主要是用来提高程序的执行效率的。 对于会多次执行到的代码（比如某个类的函数、某一个经常使用到的执行路径相关的代码，就是所谓的“热点函数”、“热点trace”），JIT会将其编译成机器码。下次再执行此代码时就直接执行机器码，从而提高了代码的执行效率。\n\n  为什么只是对热点函数、热点trace进行JIT编译，而不是全部的字节码？首先，字节码的大部分代码一般不会总是执行到（即执行频率低），而JIT是在程序运行期间编译，编译时又需要时间，在程序运行期间花时间编译一般不会执行到的代码，这不是一个好的选择。所以，JIT只编译热点函数、热点trace，对于非热点的代码仍旧在用到时用解释器去解释成机器码然后执行就可以了。 JIT编译而来的机器码是存储到内存中的，不是在硬盘上。所以，在应用重新启动时，所有的热点代码也都需要使用jit重新编译成机器码。 \n\n \t网上找到一段关于JIT在代码层面实现逻辑的说明，“每启动一个应用程序，都会相应地启动一个dalvik虚拟机，启动时会建立JIT线程，一直在后台运行。当某段代码被调用时，虚拟机会判断它是否需要编译成机器码，如果需要，就做一个标记，JIT线程不断判断此标记，如果发现被设定就把它编译成机器码，并将其机器码地址及相关信息放入entry table中，下次执行到此就跳到机器码段执行，而不再解释执行，从而提高速度”。\n\n​\t\t JIT是Dalvik虚拟机下的编译模式，随着ART在4.4版本之后替代Dalvik，编译模式也由JIT变为了AOT\n\n\n\n* Dalvik从android诞生时就存在，4.4版本之后被ART替代\n\n* JIT在android 2.2版本被引入，4.4版本之后被AOT替代\n\n* JIT只是对热点函数、热点trace进行编译，非热点函数还是走解释器\n\n* JIT编译生成的机器码存储在内存中，应用下次启动时需重新编译热点代码\n\n### AOT\n\n​\t\tART采取了AOT(Ahead-Of-Time)技术， 因为它是在应用安装时就将字节码编译成了机器码然后存放在本地（可以理解为“硬盘”）了。这样程序运行时就可以直接从本地取到机器码然后执行，大大提高了代码的执行效率。 在APK安装的时候就会做预先编译动作，编译好的文件是OAT文件，该文件本质上是一个ELF文件，这里与dex(Odex)文件最大的区别是OAT文件不再是字节码文件，而是一个可执行文件，可以更底层的与硬件接触，运行时也省去了预编译和转译的时间。\n\n​\t\tAOT作为默认的编译模式，也只是在android 5.x、6.x版本，7.0版本开始使用混合模式。 \n\n\n\n* AOT，是在应用安装时编译，优点是省去了在程序运行期间的编译时间，提高了代码的执行效率\n\n* AOT，也印在应用安装时编译，延长了应用的安装时间，增大了本地存储空间的占用\n\n* AOT作为默认编译模式，只存在于android 5.x、6.x版本\n\n### android 7.0及之后的编译模式是怎样的？\n\n​\t\t7.0版本采用的是hybird的模式，也就是JIT+AOT+解释器的结合。应用安装时不再编译，直接安装。代码执行时采用JIT的方式，对于热点trace和热点代码进行编译并产生profile文件，但这种JIT产生的编译不是持久化的。当手机进入空置或者充电状态时，系统隔一段时间就扫描一下app的profile文件，基于此profile文件制定的热点trace或者热点代码进行编译并进行持久化处理。待应用再次运行时，如本地有相关机器码，就直接运行本地的机器码而不再进行JIT编译。\n\n  此处的AOT，不再指“Ahead Of Time”，而是指“All Of the Time”。\n\n  这种混合模式的好处是，因为不再进行安装时编译，安装会变得很快；在空置或充电等状态下进行了编译，编译过的热点代码或热点trace不会再进行重复编译，执行效率也会提升。缺点是，应用前几次代码执行，效率可能一般；用户操作应用的次数越多，这种代码执行的效率越明显。\n\n### Dalvik\nDalvik使用JIT\n\n1. 使用.dex字节码，是针对Android设备优化后的DVM所使用的运行时编译字节码\n2. .odex是对dex的优化，deodex在系统第一次开机时会提取所有apk内的dex文件，odex优化将dex提前提取出，加快了开机的速度和程序运行的速度\n\n## ART\n\n- ART 使用AOT\n- 在安装apk时会进行预编译，生成OAT文件，仍以.odex保存，但是与Dalvik下不同，这个文件是可执行文件\n- dex、odex 均可通过dex2oat生成oat文件，以实现兼容性\n- 在大型应用安装时需要更多时间和空间"},{"title":"dex加载流程","url":"/2020/01/07/dex加载流程/","content":"\n## ClassLoader\n\n### Java中的ClassLoader\n\n`Bootstrap ClassLoader`： 根ClassLoader，用C++实现，专门用来加载Java的核心API：$JAVA_HOME中jre/lib/rt.jar中所有class文件rt的意思是runtime\n\n`Extension ClassLoade`r： 加载Java扩展API jre/lib/ext中的类\n\n`App ClassLoader`： 加载classpath目录下定义的class，也就是应用程序用到的ClassLoader。加载当前应用程序ClassPath下面的所有的jar和Class文件。\n\n`Custom ClassLoader`： 可以自定义的ClassLoader，可以继承这个ClassLoader然后自己实现。\n\n### Android中的`ClassLoader`\n\n`BootClassLoader`:主要用来加载`FrameWork`层的class文件\n\n`PathClassLoader`:继承自`BaseDexClassLoader`，用来加载已经安装到系统中的apk中的class文件，\n\n`DexClassLoader`:继承自`BaseDexClassLoader`，用来加载指定的目录中的class文件\n\n下面看一下 `ClassLoader`的源码，最重要的是`loadClass` 方法\n\n```java\n    protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n            // 第一步\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                try {\n                // 第二步\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n               //第三步\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    c = findClass(name);\n                }\n            }\n            return c;\n    }\n```\n\n1.  findLoadedClass(name)检查这个类是否被加载过，最终执行到native方法去查找 \n2.  如果没有并且其父类不为空，执行父类的loadClass()方法 \n3.  如果最终还是没有找到，就执行findClass(name)方法自己去加载这个类。\n\n在 `BaseDexClassLoader `中查看findClass()方法的实现\n\n```java\npublic class BaseDexClassLoader extends ClassLoader {\n\n   ......\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();\n        Class c = pathList.findClass(name, suppressedExceptions);\n        if (c == null) {\n            ClassNotFoundException cnfe = new ClassNotFoundException(\n                    \"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList);\n            for (Throwable t : suppressedExceptions) {\n                cnfe.addSuppressed(t);\n            }\n            throw cnfe;\n        }\n        return c;\n    }\n\n ......\n \n```\n\n可以看到这里调用了`pathList.findClass()`，`pathList`是`BaseDexClassLoader`的一个成员变量`DexPathList`\n\n继续查看`pathList.findClass()`\n\n```java\n public Class<?> findClass(String name, List<Throwable> suppressed) {\n        for (Element element : dexElements) {\n            Class<?> clazz = element.findClass(name, definingContext, suppressed);\n            if (clazz != null) {\n                return clazz;\n            }\n        }\n\n        if (dexElementsSuppressedExceptions != null) {\n            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));\n        }\n        return null;\n    }\n```\n\n遍历`dexElements[]`,在每一个element对象中继续调用findclass(),返回第一个不为null的值.\n\n这个Element数组是`DexPathList`初始化 的时候被创建\n\n```java\n  public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles) {\n       if (definingContext == null) {\n           throw new NullPointerException(\"definingContext == null\");\n       }\n       if (dexFiles == null) {\n           throw new NullPointerException(\"dexFiles == null\");\n       }\n       if (Arrays.stream(dexFiles).anyMatch(v -> v == null)) {\n           throw new NullPointerException(\"dexFiles contains a null Buffer!\");\n       }\n\n        this.definingContext = definingContext;\n        // TODO It might be useful to let in-memory dex-paths have native libraries.\n        this.nativeLibraryDirectories = Collections.emptyList();\n        this.systemNativeLibraryDirectories =\n                splitPaths(System.getProperty(\"java.library.path\"), true);\n        this.nativeLibraryPathElements = makePathElements(this.systemNativeLibraryDirectories);\n\n        ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();\n        this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);\n        if (suppressedExceptions.size() > 0) {\n            this.dexElementsSuppressedExceptions =\n                    suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);\n        } else {\n            dexElementsSuppressedExceptions = null;\n        }\n    }\n```\n\n可以看到` this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);`利用函数`makeInMemoryDexElements`来创建`dexElements[]`\n\n```java\n    private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles,\n            List<IOException> suppressedExceptions) {\n        Element[] elements = new Element[dexFiles.length];\n        int elementPos = 0;\n        for (ByteBuffer buf : dexFiles) {\n            try {\n                DexFile dex = new DexFile(buf);\n                elements[elementPos++] = new Element(dex);\n            } catch (IOException suppressed) {\n                System.logE(\"Unable to load dex file: \" + buf, suppressed);\n                suppressedExceptions.add(suppressed);\n            }\n        }\n        if (elementPos != elements.length) {\n            elements = Arrays.copyOf(elements, elementPos);\n        }\n        return elements;\n    }\n```\n\n遍历传入的参数`dexFiles`,对每一个`dexFiles`创建`DexFile`对象,并根据`DexFile`创建`Element`对象,加入到`elements[]`数组中,返回`elements[]`数组.\n\n## 获取A3AEECD8.dex的elements[]\n\n```c++\nGlobals::absoluteEncryptJar_ = /data/user/0/com.example.msa_sdk/.00000000000/A3AEECD8.dex\n\nv3 = __GetPathList(Globals::env_, Globals::classLoader_);\nv4 = NewStringUTF(Globals::env_, Globals::absoluteEncryptJar_);               \nv5 = NewStringUTF(Globals::env_, \"makeInMemoryDexElements\");\nv6 = CallMakeInMemoryDexElements(Globals::env_, v3, v4, v5);\n\n```\n\n`CallMakeInMemoryDexElements`实际上是执行了`\"com/bun/miitmdid/core/Jlibrary\"`中的`\"o0o0o0o0o0\"`方法,并传递四个参数分别为\n\n1. `Ldalvik/system/DexPathList` \n2. `Globals::absoluteEncryptJar_`\n3. `\"makeInMemoryDexElements\"`\n4. 0\n\n`o0o0o0o0o0`执行了\n\n```\nmakeInMemoryDexElements(dexFiles, suppressedExceptions);\n```\n\n其中`dexFiles` 为 `\"/data/user/0/com.example.msa_sdk/.00000000000/A3AEECD8.dex\"`\n\n查看`makeInMemoryDexElements`源码\n\n```java\n    private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles,\n            List<IOException> suppressedExceptions) {\n        Element[] elements = new Element[dexFiles.length];\n        int elementPos = 0;\n        for (ByteBuffer buf : dexFiles) {\n            try {\n                DexFile dex = new DexFile(buf);\n                elements[elementPos++] = new Element(dex);\n            } catch (IOException suppressed) {\n                System.logE(\"Unable to load dex file: \" + buf, suppressed);\n                suppressedExceptions.add(suppressed);\n            }\n        }\n        if (elementPos != elements.length) {\n            elements = Arrays.copyOf(elements, elementPos);\n        }\n        return elements;\n    }\n```\n\n 遍历`dexFile`,依次创建`DexFile`和`Element`，然后放到数组中返回。 \n\n数组Elements[] 数组中装有dex文件\n\n因此v6 为 `/data/user/0/com.example.msa_sdk/.00000000000/A3AEECD8.dex` 相对应的elements数组\n\n## 获取当前classloader的Elements[]\n\n```c++\nv8 = __GetElementArray(Globals::env_, Globals::classLoader_); \n```\n\n```C++\n__int64 __fastcall __GetElementArray(__int64 a1, __int64 a2)                        //__GetElementArray(Globals::env_, Globals::classLoader_);\n{\n  __int64 v2; // x21\n  __int64 v3; // x19\n  __int64 v4; // x0\n  __int64 v5; // x20\n  __int64 v6; // x0\n  __int64 v7; // x21\n  __int64 v8; // x0\n  __int64 v9; // x22\n  __int64 v10; // x0\n  __int64 v11; // x23\n\n  v2 = a2;                                                      //Globals::classLoader_\n  v3 = a1;                                                      //Globals::env_\n  v4 = FindClass(Globals::env_,\"dalvik/system/BaseDexClassLoader\");\n  v5 = v4;\n  v6 = GetFieldID(Globals::env_,v4,\"pathList\",\"Ldalvik/system/DexPathList;\");\n  v7 = GetObjectField(Globals::env_, Globals::classLoader_, v6);\n  v8 = FindClass(Globals::env_, \"dalvik/system/DexPathList\");\n  v9 = v8; \n  v10 = GetFieldID(Globals::env_,v8,\"dexElements\",\"[Ldalvik/system/DexPathList$Element;\");\n  v11 = GetObjectField(Globals::env_, v7, v10);\n  if ( v9 )\n    DeleteLocalRef(v3, v9);\n  if ( v7 )\n    DeleteLocalRef(v3, v7);\n  if ( v5 )\n    DeleteLocalRef(v3, v5);\n  return v11;\n}\n\n```\n\n\n\n其中,v7为`dalvik/system/BaseDexClassLoader`中的成员变量`pathList`的值.\n\n返回值v11为`dalvik/system/DexPathList`中的成员变量`dexElements[]`的值.\n\n\n\n因此v8为`dalvik/system/DexPathList`中的成员变量`dexElements[]`的值,即v8为 `com.bun.miitmdid.core.classLoader`中的`pathList`中的`dexElements[]`\n\n## 合并A3AEECD8.dex和classloader的Elements[] 并重新赋值\n\n```c++\n  v6 为 /data/user/0/com.example.msa_sdk/.00000000000/A3AEECD8.dex 的elements\n  v8为 com.bun.miitmdid.core.classLoader 中的pathList中的dexElements[]\n  v9 = GetArrayLength(Globals::env_, v8);                                                \n  v10 = GetArrayLength(Globals::env_, v6);\n  v11 = __NewArray(Globals::env_, \"dalvik/system/DexPathList$Element\", (unsigned int)(v9 + v10)); \n// 两个if为新建一个Elements[]值为合并之后的v6和v8\n  if ( v10 > 0 )\n  {\n    do\n    {\n      v12 = GetObjectArrayElement(Globals::env_, v6, v7);             \n      v13 = v7++;                                                     \n      SetObjectArrayElement(Globals::env_, v11, v13, v12);\n    }\n    while ( v7 != v10 );\n  }\n  v14 = 0;\n  if ( v9 > 0 )\n  {\n    do\n    {\n      v15 = GetObjectArrayElement(Globals::env_, v8, v14);              \n      v16 = v10 + v14++;                                               \n      SetObjectArrayElement(Globals::env_, v11, v16, v15);\n    }\n    while ( v14 != v9 );\n  }\n  _SetElementsToLoader(Globals::env_, Globals::classLoader_, v11);\n\n```\n\n### _`SetElementsToLoader`\n\n```c++\n__int64 __fastcall __SetElementsToLoader(__int64 a1, __int64 a2, __int64 a3)      //Globals::env_ ,Globals::classLoader_ ,v6+v8\n{\n  v3 = a3;\n  v4 = a1;\n  v5 = FindClass(Globals::env_,\"dalvik/system/BaseDexClassLoader\");\n  v6 = v5;\n  v7 = GetFieldID(Globals::env_,v5,\"pathList\",\"Ldalvik/system/DexPathList;\");\n  v8 = GetObjectField(Globals::env_, Globals::classLoader_, v7);\n  v9 = FindClass(Globals::env_, \"dalvik/system/DexPathList\");\n  v10 = v9;\n  v11 = GetFieldID(Globals::env_,v9,\"dexElements\",\"[Ldalvik/system/DexPathList$Element;\");\n  result = SetObjectField(Globals::env_, v8, v11, v3);\n  if ( v10 )\n    result = DeleteLocalRef(v4, v10);\n  if ( v8 )\n    result = DeleteLocalRef(v4, v8);\n  if ( v6 )\n    result = DeleteLocalRef(v4, v6);\n  return result;\n}\n\n```\n\n`SetObjectField`即将`classloader`中的`pathList`成员变量中的成员变量`dexElements`设置为v6+v8(A3AEECD8.dex和classloader合并之后的Elements[])\n\n## 总结\n\n　　 一个`ClassLoader`可以包含多个dex文件，每个dex文件是一个`Element`，多个dex文件排列成一个有序的数组`dexElements`数组，当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找类则返回，如果找不到从下一个dex文件继续查找 .\n\n　　通过反射获取`DexClassLoader`中的`DexPathList`中的Element数组,调用`MakeInMemoryDexElements`函数来生成`A3AEECD8.dex`的`Element`对象,然后将`A3AEECD8.dex`的`Element`对象合并进入`classloader`中的`Elements[]`来完成dex加载.\n\n## 参考文献\n\n[ClassLoader]( https://blog.csdn.net/mingyunxiaohai/article/details/86677509 )\n\n[Dexpathlist.java]( https://www.androidos.net.cn/android/9.0.0_r8/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java )\n\n[MultiDex与热修复实现原理]( https://blog.csdn.net/hp910315/article/details/51681710 )\n\n[Dex热修复原理]( https://www.jianshu.com/p/c8cd452f5eed )"},{"title":"sdk","url":"/2020/01/07/sdk/","content":"\n## 小米 1  \t\t\t\t\tcase 1\n\n```java\nClass b = Class.forName(\"com.android.id.impl.IdProviderImpl\");\nObject a = b.newInstance();\nMethod method_AAID = b.getMethod(\"getAAID\", Context.class);\nMethod method_OAID = b.getMethod(\"getOAID\", Context.class);\nMethod method_VAID = b.getMethod(\"getVAID\", Context.class);\nObject str_AAID = method_AAID.invoke(a,this);\nObject str_OAID = method_OAID.invoke(a,this);\nObject str_VAID = method_VAID.invoke(a,this);\nSystem.out.println((String)str_AAID);\nSystem.out.println((String)str_OAID);\nSystem.out.println((String)str_VAID);\n```\n\n## vivo 2  \t\t\t\t\tcase 2\n\n```java\narg8 = appid     // supplierconfig.json中vivo的appid\n\n//getAAID\nv1 = Uri.parse(\"content://com.vivo.vms.IdProvider/IdentifierId/AAID_\" + arg8);\n// this.a = context\nCursor v0 = this.a.getContentResolver().query(v1, null, null, null, null);\nv2 = v0.getString(v0.getColumnIndex(\"value\"));\n\n//getOAID\nv1 = Uri.parse(\"content://com.vivo.vms.IdProvider/IdentifierId/OAID\");\nCursor v0 = this.a.getContentResolver().query(v1, null, null, null, null);\nv2 = v0.getString(v0.getColumnIndex(\"value\"));\n\n//getVAID\nv1 = Uri.parse(\"content://com.vivo.vms.IdProvider/IdentifierId/VAID_\" + arg8);\nCursor v0 = this.a.getContentResolver().query(v1, null, null, null, null);\nv2 = v0.getString(v0.getColumnIndex(\"value\"));\n```\n\n\n\n## oppo 3 \t\t\t\t\tcase 3    \n\n```java\n//AAID\nsysParamters.f():\narg2 = \"0x1008611\" + getApplicationInfo().packageName + \"0xdzfdweiwu\"\nMessageDigest v0_3 = MessageDigest.getInstance(\"MD5\");\nv0_3.update(arg2.getBytes(\"UTF-8\"));\narg6 = v0_3.digest()\nStringBuilder v1 = new StringBuilder();\nfor(int v0 = 0; v0 < arg6.length; ++v0) {\n    int v3 = arg6[v0];\n    int v5 = (v5 & 0xF0) >> 4;\n    v1.append(d.a[v5]);\n    v1.append(d.a[v3 & 15]);\n}\nstr_AAID = v1.toString()\n\n//OAID  \nInfo v2_2 = AdvertisingIdClient.getAdvertisingIdInfo(a.a(this));\na.c = v2_2.getId()\nstr_OAID = a.c\n    \n//VAID\na.d\n```\n\n\n\n## motorola 4 \t\t\t\t\tcase 4 \n\n```java\narg9 = context\n\nthis.b = arg9.getPackageName();\nString v1 = this.b;\nSignature[] v1_2 = arg9.getPackageManager().getPackageInfo(v1, 0x40).signatures;\nbyte[] v1_3 = v1_2[0].toByteArray();\nMessageDigest v3 = MessageDigest.getInstance(\"SHA1\");\nbyte[] v3_1 = v3.digest(v1_3);\nStringBuilder v4 = new StringBuilder();\nfor(int i = 0; i < v3_1.length; ++i) {\n\tv4.append(Integer.toHexString(v3_1[i] & 0xFF | 0x100).substring(1, 3));\n}\nString v0 = v4.toString();\nthis.c = v0;\n\n\n//getAAID\nString AAID = this.a.a(this.b, this.c, \"AUID\");\n//getOAID\nString OAID = this.a.a(this.b, this.c, \"OUID\");\n//getVAID\nString VAID = this.a.a(this.b, this.c, \"DUID\");\n\n\n public String a(String arg6, String arg7, String arg8) {\n    String v0_1;\n    Parcel v1 = Parcel.obtain();\n    Parcel v2 = Parcel.obtain();\n    try {\n        v1.writeInterfaceToken(\"com.heytap.openid.IOpenID\");\n        v1.writeString(arg6);\n        v1.writeString(arg7);\n        v1.writeString(arg8);\n        this.a.transact(1, v1, v2, 0);\n        v2.readException();\n        v0_1 = v2.readString();\n    }\n    catch(Throwable v0) {\n        v2.recycle();\n        v1.recycle();\n        throw v0;\n    }\n\n    v2.recycle();\n    v1.recycle();\n    return v0_1;\n}\n\n```\n\n## 联想 5  ASUS 6\t\t\t\tcase5 = case 6 \n\n```java\npublic String b(String arg6) {\n    String v0_1;\n    Parcel v1 = Parcel.obtain();\n    Parcel v2 = Parcel.obtain();\n    try {\n        v1.writeInterfaceToken(\"com.zui.deviceidservice.IDeviceidInterface\");\n        v1.writeString(arg6);\n        this.a.transact(5, v1, v2, 0);\t\t\t//AAID\t\t\t\n        this.a.transact(1, v1, v2, 0);\t\t\t//OAID  与VAID\n        v2.readException();\n        v0_1 = v2.readString();\n    }\n    catch(Throwable v0) {\n        v2.recycle();\n        v1.recycle();\n        throw v0;\n    }\n\n    v2.recycle();\n    v1.recycle();\n    return v0_1;\n}\n//AAID\nString v0 = this.a.getPackageName();\nLog.i(OpenDeviceId.c, \"liufeng, getAAID package：\" + v0);\nString str_AAID = b(v0)\n\n//OAID\nString str_OAID = b(v0)     \n\n//VAID\nthis.a(\"liufeng, getVAID package：\" + v0);\nString str_VAID = b(v0)\n```\n\n\n\n## samsung 7 \t\t\t\tcase 7   \n\n```java\npublic String e() {\n    String v0_1;\n    Parcel v1 = Parcel.obtain();\n    Parcel v2 = Parcel.obtain();\n    try {\n        v1.writeInterfaceToken(\"com.asus.msa.SupplementaryDID.IDidAidlInterface\");\n        this.a.transact(5, v1, v2, 0);   //AAID\n        this.a.transact(3, v1, v2, 0);   //OAID\n        this.a.transact(4, v1, v2, 0);\t //VAID\n        v2.readException();\n        v0_1 = v2.readString();\n    }\n    catch(Throwable v0) {\n        v2.recycle();\n        v1.recycle();\n        throw v0;\n    }\n\n    v2.recycle();\n    v1.recycle();\n    return v0_1;\n}\n\n```\n\n\n\n## 魅族 8\t\t\t\t\t\t\t\t\t case 8\n\n```java\n//AAID调用\npublic String b(String arg6) {\n    String v0_1;\n    Parcel v1 = Parcel.obtain();\n    Parcel v2 = Parcel.obtain();\n    try {\n        v1.writeInterfaceToken(\"com.samsung.android.deviceidservice.IDeviceIdService\");\n        v1.writeString(arg6);\n        this.a.transact(3, v1, v2, 0);\n        v2.readException();\n        v0_1 = v2.readString();\n    }\n    catch(Throwable v0) {\n        v2.recycle();\n        v1.recycle();\n        throw v0;\n    }\n\n    v2.recycle();\n    v1.recycle();\n    return v0_1;\n}\n\n//OAID调用\npublic String a() {\n    String v0_1;\n    Parcel v1 = Parcel.obtain();\n    Parcel v2 = Parcel.obtain();\n    try {\n        v1.writeInterfaceToken(\"com.samsung.android.deviceidservice.IDeviceIdService\");\n        this.a.transact(1, v1, v2, 0);\n        v2.readException();\n        v0_1 = v2.readString();\n    }\n    catch(Throwable v0) {\n        v2.recycle();\n        v1.recycle();\n        throw v0;\n    }\n\n    v2.recycle();\n    v1.recycle();\n    return v0_1;\n}\n\n//VAID调用\npublic String a(String arg6) {\n    String v0_1;\n    Parcel v1 = Parcel.obtain();\n    Parcel v2 = Parcel.obtain();\n    try {\n        v1.writeInterfaceToken(\"com.samsung.android.deviceidservice.IDeviceIdService\");\n        v1.writeString(arg6);\n        this.a.transact(2, v1, v2, 0);\n        v2.readException();\n        v0_1 = v2.readString();\n    }\n    catch(Throwable v0) {\n        v2.recycle();\n        v1.recycle();\n        throw v0;\n    }\n\n    v2.recycle();\n    v1.recycle();\n    return v0_1;\n}\n//getAAID\nString v0 = this.mContext.getPackageName();\nLog.i(SumsungCore.TAG, \"liufeng, getAAID package：\" + v0);\nLog.d(SumsungCore.SAMSUNGTAG, \"getAAID Package: \" + v0);\nString str_AAID = this.mDeviceidInterface.b(v0);\n\n//getOAID\nLog.d(SumsungCore.SAMSUNGTAG, \"getOAID call\");\nString str_OAID = this.mDeviceidInterface.a();\n\n//getVAID\nString v0 = this.mContext.getPackageName();\nLog.i(SumsungCore.TAG, \"liufeng, getVAID package：\" + v0);\nLog.d(SumsungCore.SAMSUNGTAG, \"getVAID Package: \" + v0);\nString str_VAID = this.mDeviceidInterface.a(v0);\n```\n\n## ALPS 9                    case9 = case 10\n\n```java\narg9 为 context\narg10 为 new OpenId(\"aaid\") or new OpenId(\"oaid\") or new OpenId(\"vaid\")\n\nUri v1 = Uri.parse(\"content://com.meizu.flyme.openidsdk/\");\n//new String[]{arg10.c}   arg10.c 为 \"aaid\"\nv1_1 = arg9.getContentResolver().query(v1, null, null, new String[]{arg10.c}, null);\n\nValueData v0 = new ValueData(null, 0);\nv1_1.moveToFirst();\nint value = v1_1.getColumnIndex(\"value\");\nv0.a = v1_1.getString(value);\n\nv0.a 即为 AAID/OAID/VAID\n```\n\n\n\n## 努比亚 10\t\t\t\t\t\t\tcase 11\n\n```java\na.a = Uri.parse(\"content://cn.nubia.identity/identity\");\nContentProviderClient v2 = arg6.getContentResolver().acquireUnstableContentProviderClient(a.a);\n//getAAID\nv0_1 = v2.call(\"getAAID\", sysParamters.g(), null);  \nstr_AAID = v0_1.getString(\"id\");\t\t\t//或者str_AAID = v0_1.getString(\"message\");\n\n//getOAID\nv0_1 = v2.call(\"getOAID\", null, null);\nstr_OAID = v0_1.getString(\"id\");\t\t\t//或者str_OAID = v0_1.getString(\"message\");\n\n//getVAID\nv0_1 = v2.call(\"getVAID\", arg7, null);\nstr_VAID = v0_1.getString(\"id\");\t\t\t//或者str_VAID = v0_1.getString(\"message\");\n\n```\n"},{"title":"ida 动态调试","url":"/2019/11/21/ida-动态调试/"},{"title":"ARM反汇编基础","url":"/2019/11/14/ARM反汇编基础/","content":"\n \n\n## Android ARM EABI\n\n　　嵌入式设备的ABI称为嵌入式应用二进制接口.\n\n　　基于Android的EABI称为\"ARM EABI\",\n\n### armeabi\n\n"},{"title":"动态分析Android程序","url":"/2019/11/12/动态分析Android程序/","content":"\n　　在分析经过加密混淆的Android程序时,仅使用静态分析技术往往达不到理想的效果.\n\n　　动态分析分为动态跟踪和动态调试:\n\n  　　1. 动态跟踪:侧重于自动化分析\n  　　2. 动态调试:动态调试需要分析人员参与进来,依靠调试器的能力完成分析工作.\n\n## 动态分析框架\n\n　　MobSF同时支持Android,iOS,Windows平台上的软件分析,它的测试框架同时支持静态分析,动态分析和webAPI测试.\n\n\n\n## 动态分析技巧\n\n　　主流的动态分析框架除了提供了一套完整,通用的动态分析方法,通常还具备高度的可配置特性与可扩展性,但对一些应用来说,还是有一些分析要点没有提供.\n\n### 代码注入法\n\n　　一个程序在发布时通常不会保留Log信息,如果想观察程序特定位置的输出信息,需要手动进行代码注入.代码注入是指先反编译Android程序,然后在反汇编出来的smali文件中添加Log调用代码,最后重新打包程序并运行,查看输出结果. \n\n　　使用代码注入可以精确输出程序运行时的中间结果,而输出的结果则可以作为程序 分析的风向标.\n\n### 栈跟踪法\n\n　　尽管logcat配合代码注入的方法在分析程序时屡试不爽,但需要分析人员阅读大量的反汇编代码来寻找程序的输出点,且在此过程中需要多次手动注入LOG代码.因此需要一种快速定位程序关键点的方法,栈跟踪法也是属于代码注入的范畴,主要的操作是手动向反汇编后的smali文件中添加用于输出栈跟踪信息的代码.与LOG输出代码不同的是,采用栈跟踪法,只需要知道大概的代码注入点,而且注入后的反馈信息比Log注入要详细的多.栈跟踪信息记录了从程序启动到插入点所有被调用过的方法.\n\n### Method Profiling\n\n　　Windows平台上的OD有一个trace功能,其作用是在程序运行时记录每个被调用的API的名称.Android SDK也提供了类似的调试方法,它就是`Method Profiling`.\n\n## 使用JDB动态调试APK\n\n## 使用JEB动态调试APK\n\n## 使用IDA Pro动态调试APK\n\n"},{"title":" 静态分析Android程序","url":"/2019/11/09/静态分析Android程序/","content":"\n## 静态分析简介\n\n静态分析Android程序有两种方法:\n\n1. 阅读反汇编生成的Dalvik字节码,可以使用IDA pro分析DEX文件,也可以使用文本编辑器阅读baksmali反编译生成的smali文件\n2. 阅读反汇编生成的Java源码,可以使用dex2jar生成jar文件,然后使用jd-gui阅读jar文件的代码\n\n\n\n## 阅读smali代码\n\n## 阅读Java代码\n\n　　在大型APK的逆向分析中,逐行阅读smali代码的效率相对来说比较低.分析阅读高级的Java语言伪代码是提高分析效率的一种常用手段.\n\n### 将dex文件转换成jar包\n\n1. dex2jar\n2. enjarify\n\n### jar分析工具\n\n1. jd-gui\n2. jadx       特色是支持直接打开apk或dex文件查看其java伪代码\n3. bytecode-viewer     提供的插件功能并内置了几款强大的jar反混淆插件\n\n## 代码定位技巧\n\n* 入口分析法\n\n  　　从AndroidManifest.xml中找到主Activity\n\n* 信息反馈法\n\n  　　先运行目标程序,然后将程序运行时给出的反馈信息作为突破口来寻找关键代码\n\n* 特征函数法\n\n  　　寻找特定的API函数\n\n## 使用JEB进行静态分析\n\n　　JEB是一款强大的跨平台Android静态分析工具.比起jd-gui等jar查看工具,JEB提供了类似于IDA Pro的方法交叉引用与重命名功能.这些人性化的功能使JEB在Android逆向分析工具中异常突出.此外,JEB的脚本化功能,在自动化分析与对抗代码混淆中非常实用.\n\n## 使用IDA Pro进行静态分析\n\n## 使用Androguard进行静态分析\n\n"},{"title":"Android Studio混淆设置","url":"/2019/11/08/Android-Studio混淆设置/","content":"\n`Android studio` 使用`Proguard`进行混淆，其是一个压缩、优化和混淆java字节码文件的一个工具。\n\n功能：Shrinking(压缩)、Optimization(优化)、Obfuscattion(混淆)、Preverification(预校验)四个操作。\n优点：\n\n1. 删除项目无用的资源，有效减小apk大小；\n2. 删除无用的类、类成员、方法和属性，还可以删除无用的注释，最大限度的优化字节码文件；\n3. 使用简短无意义的名称重命名已存在的类、方法、属性等，增加逆向工程的难度。\n\n## 配置\n\n```\n    buildTypes {\n        release {\n            // true - 打开混淆\n            minifyEnabled true\n            // true - 打开资源压缩\n            shrinkResources true\n            // 用于设置Proguard的规划路径；\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro',\n                    '../libModule/proguard-rules.pro'\n        }\n    }\n```\n\n- proguard-android.txt：其中proguard-android.txt 是系统默认的混淆文件，具体在../sdk/tools/proguard/ 目录下，其中包含了 android 最基本的混淆，一般不需要改动；\n- proguard-rules.pro：是我们需要配置的规则；\n- 如果要配置多个Module的混淆文件，只需要后面添加逗号跟混淆文件路径；\n\n\n\n\n在工程目录下，找到 proguard-rules.pro 文件，它就是你要进行编写混淆配置的文件，在这个文件中编写混淆规则\n\n## 参考文章\n\n[Android studio 混淆配置]( https://www.jianshu.com/p/48d6bce58e47 )\n\n[Android Proguard(混淆)]( https://www.jianshu.com/p/60e82aafcfd0 )"},{"title":"常见Android文件格式","url":"/2019/11/06/常见Android文件格式/","content":"\n## 库文件\n\n　　库文件是一系列代码功能接口与资源数据的有机集合,在开发兼容不同版本系统的apk程序时,需要引入Android SDK中不同版本的android.jar文件.\n\n### jar包\n\n　　jar包其实是一个zip格式的文件,里面存放着编译后JAVA代码的class文件的集合.\n\n　　分析jar包:\n\n  1. 静态分析\n\n     　　使用jd-gui这类jar查看工具\n\n  2. 动态分析\n\n     　　PC平台上可以使用与系统特性相关的工具Dtrace或soot对jar包中的文件进行运行时跟踪\n\n          　　在Android平台中,需要将jar包集成到自己编写的apk中,再对需要分析的jar包中的类与方法进行插桩和运行时分析.\n\n### aar包\n\n　　android studio将aar文件作为全新的库文件格式,aar除了可以包含代码,还可以包含任何在开发中使用的资源数据.\n\n　　aar目录结构与apk文件类似,`class.jar`包含aar库文件中所有代码生成后的class文件,`res`目录存放所有资源,\n\n`aidl`目录存放了AIDL接口文件,`assets`目录中存放了Assets资源.`jni`目录中存放了编译好的不同版本的so库,`libs`目录中存放了aar包引用的第三方jar包,AndroidManifest.xml文件可用于定义aar包的名称,编译器版本等.\n\n​\t\t\n\n## classes.dex\n\n### dex文件验证与优化\n\n　　为了使Android程序在Dalvik虚拟机中快速,顺畅运行,有必要对Dex文件进行验证与优化,Android提供了一个专门验证与优化DEX文件的工具dexopt.\n\n### dex文件修改\n\n　　使用IDA pro定位代码,然后进行修改,修改之后的dex文件其checksum与signature字段是错误的.需要进行修正.修正方法:\n\n1. 使用010 Editor编辑器,配合脚本功能Dexfixer.lsc\n2. dex2jar提供的工具d2j-dex-recompute-checksum\n\n### MultiDex\n\n　　`MultiDex`称为dex分包技术.\n\n　　\n\n## AndroidManifest.xml\n\n　　AndroidManifest.xml 文件存放了APK的大量配置信息.\n\n　　在Android studio编译APK时,会将AndroidManifest.xml处理后打包进去.打包进去的AndroidManifest.xml被编译为AXML的二进制文件.\n\n## resources.arsc\n\n　　连接代码与资源的桥梁是R.java,该文件保存的是不同类型的资源的ID值.一个资源包含资源的名称,类型,值以及所在的package,resources.arsc包含不同语言环境中res目录下所有资源的类型,名称与ID所对应的信息.\n\n## META-INF目录\n\n 　　存放于APK签名有关的信息\n\n"},{"title":"Dalvik可执行格式与字节码规范","url":"/2019/11/04/Dalvik可执行格式与字节码规范/","content":"\nAndroid平台使用java语言来开发应用程序,但Android程序并不是运行在标准的java虚拟机上.\n\n## Dalvik虚拟机\n\n### 特点\n\n* 体积小,占用内存小\n\n* 专用dex可执行文件格式,执行速度快\n\n* 常量池采用32位索引值,对类方法名,字段名,常量寻址速度快\n\n* 寄存器架构,拥有一套完整的指令系统\n\n* 所有android程序都运行在Android系统进程中,每个进程都与一个Dalvik虚拟机实例对应.\n\n  \n\n### Dalvik虚拟机与java虚拟机的区别\n\n* 运行字节码不同,一个java字节码,一个dalvik字节码,dalvik字节码由java字节码转换过来\n* Dalvik可执行文件的体积更小\n* 虚拟机架构不同,java虚拟机是基于栈架构的.dalvik是基于寄存器架构的,访问速度快很多\n\n\n\n### 虚拟机执行流程\n\nAndroid系统由Linux内核,函数库,Android运行时,应用程序框架和应用程序组成.Dalvik属于Android运行时\n\n![Android架构](Dalvik可执行格式与字节码规范/android系统架构.jpg)\n\n\n\n​\t\tAndroid系统启动并加载内核后,会立即执行init进程.init进程先完成设备的初始化工作,再读取init.rc文件并启动系统中重要的外部程序Zygote.\n\n​\t\tZygote是Android系统中所有进程的孵化器进程.Zygote启动后,会先初始化Dalvik虚拟机,再启动system_server进程并进入Zygote模式.在执行一个Android应用程序时,system_server进程通过Binder IPC方式将命令发送给Zygote.Zygote收到命令后,通过fork自身创建一个Dalvik虚拟机的实例来执行应用程序的入口函数.从而完成程序的启动过程.\n\n​\t\t进程fork后,执行工作交给Dalvik虚拟机来完成.\n\n\n\n### 虚拟机的执行方式\n\n即时编译(JIT)又称动态编译,是通过在运行时将字节码翻译为机器码使得程序的执行速度加快的技术.\n\n主流JIT包括两种字节码编译方式\n\n* method方式:以方法为单位进行编译\n* trace方式:以trace为单位进行编译\n\nDalvik虚拟机默认采用trace的方式编译代码\n\n## Dalvik语法基础\n\n### Dalvik寄存器\n\nv命名法:表示函数所使用的局部变量与参数\n\np命名法:函数中引入的参数命名从p0开始\n\n\n\n## 参考文章\n\n[Dalvik虚拟机学习之路]( https://www.jianshu.com/p/92c2f732d2d6 )\n\n[Dalvik虚拟机原理]( https://www.jianshu.com/p/14147171a599 )\n\n"},{"title":"dex格式解析","url":"/2019/10/30/dex格式解析/","content":"\n## 前言\n\n​\t\t我们都知道 .java 源文件经过编译器编译会生成 JVM 可识别的 .class 文件。在 Android 中，不管是 Dalvik 还是 Art，和 JVM 的区别还是很大的。Android 系统并不直接使用 Class 文件，而是将所有的 Class 文件聚合打包成 DEX 文件，DEX 文件相比单个单个的 Class 文件更加紧凑，可以直接在 Android Runtime 下执行。\n\n​\t\t 当java程序编译成class后，还需要使用dx工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，实验表明，dex文件是传统jar文件大小的50%左右 . dex文件作为Android APK的组成部分，其主要是Android的Java代码经过编译生成class文件，再经过dx命令生成的。这里面包括了APK的源码，反编译时最主要就是对这个文件进行反编译。 \n\n![android文件](dex格式解析/安卓文件.png)\n\n## dex文件结构\n\n![dex文件格式](https://upload-images.jianshu.io/upload_images/2466095-82f7d70102fe33d2)\n\n## dex文件分析\n\n dex 文件的分析，主要分为三大块： ① Dex 文件头 ② 各种数据的数组，包括字符串、类型、方法原型、字段、方法 ③ 类数据 ④ 其他 \n\n使用010 Editor打开dex文件\n\n![010 Editor dex文件分析](dex格式解析/dex分析.png)\n\n## 参考文章\n\n[Android逆向笔记 —— DEX 文件格式解析](https://www.jianshu.com/p/a4632f566039)\n\n[Android dex文件解析]( https://www.jianshu.com/p/b79c729f326b )\n\n[Android逆向之Dex文件]( https://www.cnblogs.com/ltyandy/p/11603083.html )\n\n"},{"title":"aar和jar文件简介","url":"/2019/10/29/aar和jar文件简介/","content":"\n## 前言\n\n​\t\t在使用 Eclipse 开发 Android 的那个时代（其实也就几年前而已），如果想代码打包，只有 `JAR` 包一个方法，但是 `JAR` 只能把 Java 文件代码打包进去，如果要使用一个有布局和资源的库的话，除了将 `JAR` 放入 libs 外,还需要引入相关的资源和配置文件，十分不优雅。\n\n​\t\tAndroid Studio 出来之后，出现了一个新的方法，打包 `AAR` 文件 ，这个不仅可以把 Java 文件给打进去，还包含 AndroidManifest.xml 和资源文件等，使用的话，直接引入一个 `AAR` 文件就足够了，非常方便。\n\n## jar和aar的区别\n\n*.jar：只包含了class文件与清单文件，不包含资源文件，如图片等所有res中的文件。\n\n*.aar：包含所有资源，class以及res资源文件全部包含\n\n如果你只是一个简单的类库那么使用生成的.jar文件即可；如果你的是一个UI库，包含一些自己写的控件布局文件以及字体等资源文件那么就只能使用.aar文件。\n\n1. *.jar，JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。找一个jar文件，然后修改后缀名为‘zip’或者‘rar’格式，然后解压该文件，打开解压后的文件夹，截图如下所示：\n2. *.jar，JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。\n\n\t## ARR文件结构\n\naar包是Android Library Project的二进制发布包。\n\n文件的扩展名是aar，而且maven包类型也应该是aar， 不过这文件本身就是一个简单的zip文件，里面有如下的内容：\n\n- /AndroidManifest.xml (必须)\n- /classes.jar (必须)\n- /res/ (必须)\n- /R.txt (必须)\n- /assets/ (可选)\n- /libs/*.jar (可选)\n- /jni/<abi>/*.so (可选)\n- /proguard.txt (可选)\n- /lint.jar (可选)\n\n这些条目，都在zip文件的根目录下。\n\nR.txt 文件是 aapt --output-text-symbols 的输出。\n\n## 参考文章\n\n[jar包与aar包文件的区别]( https://www.jianshu.com/p/d7ef84586949 )\n\n[Android中aar与jar的区别]( https://www.jianshu.com/p/0a2572a63ed5 )"},{"title":"如何分析一个程序","url":"/2019/10/29/如何分析一个程序/","content":"\n## 编写一个安卓程序\n\n在 Android studio 中编写一个注册码的应用程序\n\n![app](如何分析一个程序/app.png)\n\n```JAVA\nprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        setTitle(R.string.unregister);\n        final EditText edit_username = (EditText)findViewById(R.id.editText1);\n        final EditText edit_sn = (EditText)findViewById(R.id.editText2);\n        final Button btn_register = (Button)findViewById(R.id.button);\n        btn_register.setOnClickListener(new View.OnClickListener(){\n            public void onClick(View v){\n                if (!checkSN(edit_username.getText().toString().trim(),edit_sn.getText().toString().trim())){\n                    Toast.makeText(MainActivity.this,R.string.unsuccessed,Toast.LENGTH_SHORT).show();\n                }\n                else{\n                    Toast.makeText(MainActivity.this,R.string.successed,Toast.LENGTH_SHORT).show();\n                    btn_register.setEnabled(false);\n                    setTitle(R.string.registered);\n                }\n            }\n        });\n    }\n    \n```\n\ncheckSN用于验证用户名和注册码是否匹配.\n\n```java\nprivate boolean checkSN(String username, String sn) {\n        try{\n            if ((username == null) || (username.length() == 0)) {\n                return false;\n            }\n            if ((sn == null) || (sn.length() != 16)) {\n                return false;\n            }\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(username.getBytes());\n            String hexstr = \"\";\n            StringBuffer hexString = new StringBuffer();\n            byte[] bytes = digest.digest();\n            for (int i=0; i<bytes.length; i++){\n                if(Integer.toHexString(0xFF & bytes[i]).length() < 2){\n                    hexstr = \"0\"+Integer.toHexString(0xFF & bytes[i]);\n                }else{\n                    hexstr = Integer.toHexString(0xFF & bytes[i]);\n                }\n                hexString.append(hexstr);\n            }\n            StringBuilder sb = new StringBuilder();\n            for(int i =0; i < hexString.length();i+=2){\n                sb.append(hexString.charAt(i));\n            }\n            String userSN = sb.toString();\n            if(!userSN.equalsIgnoreCase(sn)){\n                return false;\n            }\n        }catch(NoSuchAlgorithmException e){\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n```\n\n## Android studio模拟器\n\nAMD的cpu不支持`Android studio`的默认AVD,可以使用 `genymotion`安卓模拟器\n\n1. 到[官网]( https://www.genymotion.com/ )下载安装个人版`genymotion`\n2. 新建一个虚拟机设备\n3. 在AndroidStudio中下载Genymotion插件: genymotion\n4. 点击 View->toobar ,这样就可以点击genymotion的图标打开\n\n## 破解安卓应用程序\n\n破解Android程序的方法通常是:使用apktool反编译apk文件,生成smali格式的反汇编代码,通过阅读smali文件的代码来理解程序的运行机制,找到突破口,并对代码进行修改;使用Apktool重新编译生成的APK文件并对其进行签名.\n\n* 下载apktool\n  \n*  https://ibotpeaches.github.io/Apktool/install/ \n  \n* 分析apk文件\n\n  ​\t\tapktool反编译apk文件\n\n  ```\n  apktool d ./app.apk -o outdir\n  ```\n\n  \n\n  ​\t\t对大部分Android程序来说,错误提示信息是指引我们找到关键代码的明灯.错误提示代码附近通常就是程序的核心验证代码,错误提示属于Android程序中的字符串资源.\n\n  ​\t\tres/values/strings.xml文件的内容,除了系统默认生成的一系列\"abc_\"开头的字符串,其他都是程序使用的字符串.\n\n  ![Strings.xml](如何分析一个程序/strings.png)\n\n  ​\t\t在开发Android程序时,strings.xml中的字符串资源都在R.java文件的String类中标识,每个字符串都有唯一的int类型的索引值,所有的索引值都在与strings.xml同目录下的public.xml文件中.\n\n  ![public.xml](如何分析一个程序/public.png)\n\n  ​\t\t利用grep 对反编译目录进行查找,找出关键代码所在位置\n\n  ![找出关键代码](如何分析一个程序/grep.png)\n\n* 修改smali代码\n\n  分析其smali代码,然后修改其跳转指令 if-nez 改为 if-eqz (if-eqz与if-nez功能相反)\n\n* 重新编译APK文件并签名\n\n  ```apktool b outdir```\n\n   [apk手动签名](https://hbltjdw.github.io/2019/10/28/apk手动签名/) \n\n  "},{"title":"adb总结","url":"/2019/10/28/adb总结/","content":"\n## adb安装应用\n\n* 开启USB调试\n  1. 模拟器或者USB连接的手机,点击`设置`,连续点击`版本号`,进入`开发者选项`\n  2. 进入`开发者选项`,打开`USB调试`\n\n* adb安装应用\n\n  ````\n  adb devices    \t\t\t\t//查看设备是否在线\n  adb install xxx.apk\t\t\t//安装应用\n  ````\n\n  \n\n## 参考文章\n\n[ADB总结]( https://www.jianshu.com/p/899fef07929f )\n\n"},{"title":"apk手动签名","url":"/2019/10/28/apk手动签名/","content":"\n## V1和V2签名\n\n1. V1签名：\n   来自` JDK （ jarsigner ）`,对 zip 压缩包的每个文件进行验证，签名后还能对压缩包修改（移动/重新压缩文件）\n   对V1签名的 apk/jar 解压,在 META-INF 存放签名文件( MANIFEST.MF, CERT.SF, CERT.RSA )\n   其中 `MANIFEST.MF` 文件保存所有文件的 SHA1 指纹(除了 META-INF 文件),由此可知:**V1签名是对压缩包中单个文件签名验证**\n2. V2签名：\n   来自 Google（apksigner），对 zip 压缩包的整个文件验证，签名后不能修改压缩包(包括 zipalign )\n   对V2签名的 apk 解压,没有发现签名文件,重新压缩后V2签名就失效, 由此可知: **V2签名是对整个 APK 签名验证**\n3. V2签名优点：\n   签名更安全（不能修改压缩包）\n   签名验证时间更短（不需要解压验证），因此安装速度更快\n\n## V2签名过程\n\n1. `zipalign` \n\n   位于 Android SDK/build-tools/SDK 版本 /zipalign.exe\n   zipalign 是对 zip 包对齐的工具，使APK包内未压缩的数据有序排列对齐，从而减少 APP 运行时消耗\n\n   ```\n   zipalign -v 4 in.apk out.apk \t\t//4字节对齐优化命令\n   zipalign -c -v 4 in.apk \t\t\t//检查 APK 是否对齐\n   ```\n\n2. `apksigner`\n\n   这个工具位于SDK目录的`build-tools`目录下。必须说明的是，v2签名方式时在`Android7.0`后才推出的，所以只有版本>25的`SDK\\build-tools\\`中才能找到`apksigner.jar`.\n\n   ```\n   java -jar apksigner.jar sign           \t\t\t//执行签名操作\n   --ks 你的jks路径                                \t//jks签名证书路径\n   --ks-key-alias 你的alias           \t\t\t\t//生成jks时指定的alias\n   --ks-pass pass:你的密码          \t\t\t\t//KeyStore密码\n   --key-pass pass:你的密码   \t\t\t\t\t\t//签署者的密码，即生成jks时指定alias对应的密码\n   --out output.apk                         \t\t//输出路径\n   input.apk                                   \t//被签名的apk\n   \n   ```\n\n   示例\n\n   ```\n   java -jar apksigner.jar sign  --ks key.jks  --ks-key-alias releasekey  --ks-pass pass:pp123456  --key-pass pass:pp123456  --out output.apk  input.apk\n   ```\n\n   \n\n3. 检查是否签名成功\n\n   ```\n   java -jar apksigner.jar verify -v my.apk\n   ```\n\n   \n\n##　参考文章\n\n[Android开发之通过apksigner对apk进行v2签名]( https://www.jianshu.com/p/e1e2fd05bb62 )\n\n[V1 和 V2 签名工具]( https://www.jianshu.com/p/db8751060146 )\n\n"},{"title":"Smali语法学习","url":"/2019/10/25/Smali语法学习/","content":"\n* Smali 简介\n\n  ​\t\t`Dalvik虚拟机`是google专门为`Android`平台设计的一款虚拟机,区别于标准 Java 虚拟机 JVM 的 class 文件格式，`Dalvik VM` 拥有专属的 DEX 可执行文件格式和指令集代码。`smali` 和 `baksmali` 是针对 DEX 执行文件格式的汇编器和反汇编器，反汇编后 DEX 文件会产生`.smali` 后缀的代码文件.`smali`代码拥有特定的格式与语法，`smali`语言是对 `Dalvik` 虚拟机字节码的一种解释。\n\n  ​\t\t虽然主流的 DEX 可执行文件反汇编工具不少，如 `Dedexer`、`IDA Pro` 和 `dex2jar+jd-gui`，但 `Smali `提供反汇编功能的同时，也提供了打包反汇编代码重新生成DEX的功能，因此 `Smali`被广泛地用于 APP 广告注入、汉化和破解，ROM 定制等方面。\n\n  ​\t\t简单来说就是用java写的代码编译成class打包成`dex`文件后使用`baksmali`程序逆向回来的一种语法。\n\n* Smali 学习\n\n  ​\t\t在`Android studio`中查找插件`java2smali`然后就可以把任何JAVA代码转换成`smali`进行学习.\n\n  ​\t\t然后可以对照着java代码来逐行分析这个`smali`文件。注意.line关键字就是用来描述当前代码在java源文件中的行数。然后你可以通过对照两组代码的方法进行反推。这样就可以很轻松的学会看`smali`文件。\n\n* 参考文章\n\n  [Smali语法]( https://blog.csdn.net/Kelaker/article/details/84403369 )\n\n  [Smali 语法解析——Hello World]( https://www.jianshu.com/p/1a2e2da93b72 )\n\n  [github Smali]( https://github.com/JesusFreke/smali )\n\n  [Dalvik 字节码]( https://source.android.google.cn/devices/tech/dalvik/dalvik-bytecode )\n\n"},{"title":"常见逆向分析工具","url":"/2019/10/24/常见逆向分析工具/","content":"\n* `ApkTool` \n\n​\t\tAndroid逆向分析工具,提供了APK的反编译与回编译的功能,让APK重打包成为可能,以命令行操作的Apktool使用起来更加简单便捷.\n\n\n\n* `smali/baksmali`\n\n​\t\tDEX文件的反编译与回编译工具.提供了smali语法格式,使DEX文件的修改可以基于smali的汇编指令完成.Apktool底层就是使用它提供的dexlib库来生成smali反汇编文件.\n\n\n\n* `dex2jar`\n\n​\t\t将dex文件转换为jar包的工具,转换后的jar包可以利用`jd-gui`等工具查看java代码\n\n\n\n* `010Editor`\n\n​\t\t跨平台的二进制编辑器.可以使用文件格式模板对二进制文件进行查看和编辑."},{"title":"Android程序分析环境搭建","url":"/2019/10/23/Android程序分析环境搭建/","content":"\n## jdk 安装配置\n\n------\n\n* **jdk下载**\n\n```\nhttps://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html\n```\n\n* **jdk环境配置**\n\n|           | 值                                               |\n| --------- | ------------------------------------------------ |\n| CLASSPATH | %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar |\n| JAVA_HOME | C:\\Program Files\\Java\\jdkxxxx                    |\n| PATH      | %JAVA_HOME%\\bin;%JAVA_HOME%\\lib\\tools.jar        |\n\n------\n\n\n\n## Android studio下载\n\n------\n\n\n\n* **Android studio下载**\n\n```\nAndroid studio 下载地址:http://www.android-studio.org/index.php\n下载安装\n```\n\n------\n\n## sdk\n\n------\n\n 目前官网上已经没有单独的SDK下载安装包了。目前官网推荐的是下载包含有Android SDK的Android Studio。 \n\nndk-bundle,cmake,lldb为ndk的工具,新版本的android工程使用cmake构建,并使用lldb进行调试.\n\n![sdk配置](Android程序分析环境搭建/sdk.png)\n\n* **环境变量**\n\n  包含`adb`,`fastboot`的`platform-tools`目录,包含`aapt`,`apksigner`,`dexdump`,`zipalign`的`build-tools/29.0.1`目录,包含`android`,`monitor`的`tools`目录,包含`emulator`的`emulator`目录,加入到Path环境变量中\n\n  在命令行输入`emulator -version`和`adb version`观察输出是否正确\n\n  `NDK`根目录加入到NDK_HOME和Path环境变量中.\n\n  在命令行输入`ndk-bulid -v`观察输出是否正确\n\n------\n\n\n\n## NDK\n\n------\n\n`Native Development kit`\n原生开发工具包（NDK）是一组在 Android 应用中利用 C 和 C++ 代码的工具。因为 Java 无法直接调用 C 和 C++ 的代码，想要在 `Android` 应用中使用原生代码，NDK 便应运而生。NDK是一个包含API、交叉编译器、链接程序、调试器、构建工具、文档和示例应用程序的综合工具集。\nNDK 的核心目的之一是让 C 和 C++ 源代码构建为可用于应用的共享库。\n\n* **`NDK`工具介绍**\n\n  `ndk-build`：编译`Android`动态链接库.so\n  `ndk-gdb`:` GUN`调试器相关\n  `ndk-stack`：原生层堆栈信息 \n\n* **`JNI`**\n\n  `JNI`：`Java Native Interface`，是Java语言提供的一种通用接口，用于Java代码与本地化代码的交互。本地化代码是so文件，它是直接编译成的与机器相关的二进制代码。\n  `jni`通过调用动态链接库（`windows`下是`dll`，`linux`下是`so`）来实现对`C\\C++`方法的调用。\n\n------\n\n\n\n## 参考文章\n\n------\n\n[NDK 简介（Java使用原生代码）]( https://www.jianshu.com/p/a21ed1e90da0 )\n\n"},{"title":"aidl简介","url":"/2019/10/23/aidl简介/","content":"\n## AIDL简介\n\n------\n\n​\t\t`AIDL`是一个缩写，全称是`Android Interface Definition Language`，也就是Android接口定义语言。是的，首先我们知道的第一点就是：`AIDL`是一种语言。\n\n​\t\t 设计`AIDL`这门语言的目的就是为了实现进程间通信。 \n\n​\t\t 其实`AIDL`这门语言非常的简单，基本上它的语法和`Java`是一样的，只是在一些细微处有些许差别.\n\n------\n\n\n\n##  参考文章\n\n------\n\n[Android AIDL使用详解]( https://www.jianshu.com/p/29999c1a93cd )"},{"title":"apk打包流程","url":"/2019/10/23/apk打包流程/","content":"\n## apk打包流程\n\n1.  打包资源文件，生成R.java文件 \n2.  处理AIDL文件，生成对应的.java文件\n3.  编译Java文件，生成对应的.class文件 \n4.  把.class文件转化成Davik VM支持的.dex文件 \n5.  打包生成未签名的.apk文件 \n6.  对未签名.apk文件进行签名 \n7.  对签名后的.apk文件进行对齐处理 \n\n\n\n![apk打包流程](apk打包流程/apk.png)\n\n## apk打包工具介绍\n\n| 工具名称   | 功能介绍                                 |\n| ---------- | ---------------------------------------- |\n| aapt       | Android资源打包工具                      |\n| aidl       | Android接口描述语言转化为.java文件的工具 |\n| javac      | Java Compiler,java代码转class文件        |\n| dex        | 转化.class文件为Davik VM能识别的.dex文件 |\n| apkbuilder | 生成apk包                                |\n| jarsigner  | .jar文件的签名工具                       |\n| zipalign   | 字节码对齐工具                           |\n\n\n\n## 参考文章\n\n[apk打包流程]( https://www.jianshu.com/p/a134d00e81ab )"},{"title":"apk文件结构","url":"/2019/10/22/apk文件结构/","content":"\n* **assets**\n\n  ​\t存放需要打包到APK中的静态文件\n  \n  \n  \n* **lib**\n\n    动态链接库,存放应用程序依赖的native库文件，一般是用C/C++编写，这里的lib库可能包含4中不同类型，根据CPU型号的不同，大体可以分为ARM，ARM-v7a，MIPS，X86，分别对应着ARM架构，ARM-V7架构，MIPS架构和X86架构\n    \n\n\n* **META-INF**\n\n  ​\t存放应用程序签名和证书的目录,签名信息可以验证APK文件的完整性.AndroidSDK在打包APK时会计算APK包中所有文件的完整性，并且把这些完整性保存到META-INF文件夹下，应用程序在安装的时候首先会根据META-INF文件夹校验APK的完整性，这样就可以保证APK中的每一个文件都不能被篡改。\n  \n  \n  \n* **res**\n\n  ​\t存放应用程序的资源,存在这个文件夹下的所有文件都会映射到Android工程的.R文件中\n  \n  \n  \n* **AndroidManifest.xml**\n\n  ​\tAndroid应用程序的配置文件,开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册.\n  \n  \n  \n* **classes.dex**\n\n  ​\t传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。\n  \n  \n  \n* **resources.arsc**\n\n    用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。\n\n------\n\n![APK典型结构](apk文件结构/apk_struct.png)\n\n"},{"title":"Markdown语法","url":"/2019/10/22/Markdown语法/","content":"## `Markdown`常见语法\n\n`Markdown`是兼容`html`的语法的一种轻量级标记语言,它允许人们使用易读易写的纯文本格式编写文档。   \n`Markdown`可以在有道云笔记、Mahua在线编辑、简书等进行编辑\n\n* **标题**\n\n```\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n    #### 四级标题\n    ##### 五级标题\n    ###### 六级标题\n\n```\n\n* **字体**\n\n```\n    **这是加粗的文字**\n    *这是倾斜的文字*`\n    ***这是斜体加粗的文字***\n    ~~这是加删除线的文字~~\n\n```\n\n* **换行**  \n  在上一行后面加两个以上空格，然后另起一行\n\n```\n我是第一行   \n我是第二行\n我是第二行\n\n```\n\n* **列表**  \n  无序列表用 - + * 任何一种都可以  \n\n```\n- 列表内容\n+ 列表内容\n* 列表内容\n\n```\n\n  有序列表 \n\n```\n1.列表内容\n2.列表内容\n3.列表内容\n\n```\n\n* **插入图片**\n\n  * 插入本地图片\n\n    ```\n    ![avatar](/home/picture/1.png)\n    \n    ```\n\n  * 插入网络图片\n\n    ```\n    ![avatar](http://baidu.com/pic/doge.png)\n    \n    ```\n\n  * 把图片存入markdown文件\n\n    用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置.\n\n    ```\n    ![avatar](data:image/png;base64,iVBORw0......)\n    \n    ```\n  \n* **插入超链接**\n\n  ```\n  [超链接文字](url)\n  ```\n\n* **插入表格**\n\n  ```\n  | 一个普通标题 | 一个普通标题 | 一个普通标题 |\n  | ------ | ------ | ------ |\n  | 短文本 | 中等文本 | 稍微长一点的文本 |\n  | 稍微长一点的文本 | 短文本 | 中等文本 |\n  ```\n\n  \n\n"},{"title":"github-hexo搭建个人博客","url":"/2019/10/22/github-hexo搭建个人博客/","content":"------\n\n\n\n## `github`非对称加密认证\n\n------\n\n首先配置用户\n\n```\ngit config --global user.name \"xxx\"\ngit config --global user.email \"xxx@xx.com\"\n```\n\n生成私钥公钥\n\n```\nssh-keygen -t rsa -C \"your email@xxx.com\" \n```\n\n公钥为`id_rsa.pub`,打开,复制\n\n打开浏览器，登录`GitHub`，点击头像，选择`setting`，左侧有个`SSH and GPG keys` ，选择`new SSH key `,title随便写，将复制的内容黏贴上去. \n\n测试一下，`git bash`输入\n\n```\nssh -T git@github.com \n```\n\n------\n\n\n\n## `github page`设置\n\n------\n\n`github page`是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 `Github` 上，你可以选择使用`Github Pages`默认提供的域名 `github.io` 或者自定义域名来发布站点，更便利地是你直接从你的`GitHub`存储库托管。只需编辑和推送你的`blog`，并且你的更改是实时的。\n\n登录`GitHub`并创建一个名为`username.github.io`的新存储库\n\n![github_page](github-hexo搭建个人博客/github_page.png)\n\n------\n\n\n\n## `hexo`安装\n\n------\n\n\n\n1. 安装hexo\n\n```\nnpm install hexo-cli -g\n```\n\n2. 初始化\n\n   安装完成后，建一个文件夹（如`myblog`），执行以下指令(在`myblog`路径下)，`Hexo` 即会自动在目标文件夹建立网站所需要的所有文件\n\n```\nhexo init\nnpm install\n```\n\n------\n\n\n\n## `hexo`发布、删除文章即相关配置\n\n------\n\n\n\n* **`hexo`目录分析**\n\n  ```\n  deploy：执行hexo deploy命令部署到GitHub上的内容目录\n  public：执行hexo generate命令，输出的静态网页内容目录\n  scaffolds：layout模板文件目录，其中的md文件可以添加编辑\n  scripts：扩展脚本目录，这里可以自定义一些javascript脚本\n  source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。\n  drafts：草稿文章\n  posts：发布文章\n  themes：主题文件目录\n  _config.yml：全局配置文件，大多数的设置都在这里\n  package.json：应用程序数据，指明hexo的版本等信息，hexo框架的参数和所依赖插件\n  ```\n\n* **发布文章**\n\n  ```\n  $ hexo new [layout] “title”\n  ```\n\n  layout有三种 `post`、`page` 和 `draft` \n\n  在`_config.yml`中设置默认`layout`为`draft`\n\n  ```\n  default_layout: draft\n  ```\n\n  * 生成草稿\n\n    ```\n    hexo new “title”\n    ```\n\n  * 发布草稿\n\n    ```\n    hexo publish \"title“\n    ```\n\n  * 生成静态文件\n\n    ```\n    hexo clean\n    hexo generate\n    \n    ```\n\n  * 发布到github\n\n    ```\n    hexo deploy\n    ```\n  \n* **删除文章**\n\n  1. 到目录`/source/_posts`下删除相应的文章\n  2. ```$ hexo g```\n  3. ```$ hexo d```\n\n* **插入图片**\n\n  1. 进入博客根目录下,查看`_config.yml`文件,设置`post_asset_folder:true`\n  2. 设置 `post_asset_folder` 参数后，在新建博客文章时，`Hexo` 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到此文件夹内，这样就可以更方便的使用资源。\n  3. 插件的安装``` npm install https://github.com/CodeFalling/hexo-asset-image --save```\n  4. 插入图片时,先把图片复制到文件夹,然后设置图片地址为`文件夹名/图片名称.png`\n------\n\n\n\n## 将`hexo`发布到`github`\n\n------\n\n```\nhexo clean\nhexo generate\nhexo deploy\n```\n\n\n\n------\n\n\n\n## 参考文献\n\n[Github+Hexo一站式部署个人博客](https://www.jianshu.com/p/85192626faf3)\n\n"},{"title":"Hello World","url":"/2019/10/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]